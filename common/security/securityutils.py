"""Signature creation consists of two Steps.
1. Reference regeneration:
    a)XML Element(Here: Body) that will be signed is being converted to EXI
    b)SHA-256 is being applied to the generated EXI Value
    c)Base64 to the generated SHA-256 value -> Digest Value
    d)Generate SignedInfo and store digest value
2. Signature generation:
    a)Whole SignedInfo element will be converted to EXI
    b)ECDSA with SHA-256 will be used to sign the EXI value
    c)Base64 will be used to the generated signature value
    d)The final value will be stored in the <SignatureValue> element of <Signature>
"""
# pylint: disable=import-error
import os
import base64
import hashlib
import random
from iso15118.common import java_caller
from cryptography.hazmat.primitives import serialization
from cryptography import x509
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.serialization.pkcs12 import load_key_and_certificates
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from iso15118.common.XML import msgbody1, msgdatatypes1, msgxmlschema1, msgDef1, msgheader1


def load_private_key(path):
    """Load an private key object. Object has the properties of the cryptography library

    Args:
        path (String): Path of private key

    Returns:
        EllipticCurvePrivateKey: Private key python object.
    """
    _f = open(path, "rb")
    private_key = _f.read()

    evcc_private_key = serialization.load_pem_private_key(
        private_key, b'123456')

    return evcc_private_key


def aes_encrypt(derived_key, contract_private_key):
    """AES-CBC-128 Block method to encrypt the contract private key.

    Args:
        derived_key (EllipticCurvePrivateKey): The derived key that was generated by using HDKF on the session key
        (ECDH exchange altorithm between DH private key and OEM public key)
        contract_private_key (EllipticCurvePrivateKey): The private key corresponding to the contract certificate

    Returns:
        bytes: Encrypted private key corresponding to the contract certificate
    """
    _iv = os.urandom(16)
    contract_private_key = pad(contract_private_key, AES.block_size)

    aes_mode = AES.MODE_CBC
    obj = AES.new(derived_key, aes_mode, _iv)
    ciphertext = obj.encrypt(contract_private_key)
    return ciphertext


def aes_decrypt(derived_key, encrypted_contract_private_key):
    """AES-CBC-128 Block method to decrypt the contract private key.

    Args:
        derived_key (EllipticCurvePrivateKey): The derived key that was generated by using HDKF on the session key
        (ECDH exchange altorithm between DH public key and OEM private key)
        encrypted_contract_private_key: The encrypted contract private key

    Returns:
        bytes: Contract private key corresponding to the contract certificate
    """
    _iv = os.urandom(16)
    aes_mode = AES.MODE_CBC
    obj = AES.new(derived_key, aes_mode, _iv)
    plaintext = unpad(obj.decrypt(base64.b64decode(encrypted_contract_private_key)),
                      AES.block_size)
    return plaintext


# def generate_certificate_installation_res_body():
#     """Creates an empty CertificateInstallationResponse Body. Will be used as a template later on
#     to the be filled with the SAProvisioningCertificateChain, ContractSignatureCertChain,
#     ContractSignatureEncryptedPrivateKey, DHpublickey and eMAID
#
#     Returns:
#         CertificateInstallationRes XML Element: An empty element containing
#         the certificate chains with the following format:
#         <CertificateInstallationRes>
#             <ResponseCode>
#             <SAProvisioningCertificateChain>
#                 <Certificate>
#                     <SubCertificates>
#                         <Certificate>
#                         <Certificate>
#             <ContractSignatureCertChain>
#                 <Certificate>
#                     <SubCertificates>
#                         <Certificate>
#                         <Certificate>
#             <ContractSignatureEncryptedPrivateKey>
#             <DHpublickey>
#
#     """
#     certinstres = msgbody1.CertificateInstallationResType()
#     certinstres.ResponseCode = msgbody1.responseCodeType.OK
#
#     # SAProvisioningCertificateChain
#     saprovcertchain = msgbody1.CertificateChainType()
#     saprovcertchain.Certificate = b""
#
#     sasubcertificates = msgdatatypes1.SubCertificatesType()
#     sasubcertificates.add_Certificate(b"")
#     sasubcertificates.add_Certificate(b"")
#
#     saprovcertchain.SubCertificates = sasubcertificates
#     certinstres.SAProvisioningCertificateChain = saprovcertchain
#     # ContractSignatureCertChain
#     contractsignaturecertchain = msgbody1.CertificateChainType()
#     contractsignaturecertchain.Certificate = b""
#
    # contractsubcertificates = msgdatatypes1.SubCertificatesType()
    # contractsubcertificates.add_Certificate(b"")
    # contractsubcertificates.add_Certificate(b"")
    #
    # contractsignaturecertchain.SubCertificates = contractsubcertificates
    #
    # certinstres.ContractSignatureCertChain = contractsignaturecertchain
    #
    # # ContractSignatureEncryptedPrivateKey
    # certinstres.ContractSignatureEncryptedPrivateKey = msgdatatypes1.ContractSignatureEncryptedPrivateKeyType(
    #     valueOf_=b"")
    #
    # # DHpublickey
    # certinstres.DHpublickey = msgdatatypes1.DiffieHellmanPublickeyType(
    #     valueOf_=b"")
    #
    # # eMAID
    # certinstres.eMAID = msgdatatypes1.EMAIDType(valueOf_="DE1ABCD2EF357A")
    # return certinstres

""" use a loop to create the two certificate chain types (SAProvisioningCertificateChain and ContractSignatureCertChain)
        with their corresponding sub-certificates so as to reduce code duplication and easier to modify the number of sub-certificates if needed """
def generate_certificate_installation_res_body():
    """Creates an empty CertificateInstallationResponse Body. Will be used as a template later on
    to be filled with the SAProvisioningCertificateChain, ContractSignatureCertChain,
    ContractSignatureEncryptedPrivateKey, DHpublickey, and eMAID

    Returns:
        CertificateInstallationRes XML Element: An empty element containing
        the certificate chains with the following format:
        <CertificateInstallationRes>
            <ResponseCode>
            <SAProvisioningCertificateChain>
                <Certificate>
                    <SubCertificates>
                        <Certificate>
                        <Certificate>
            <ContractSignatureCertChain>
                <Certificate>
                    <SubCertificates>
                        <Certificate>
                        <Certificate>
            <ContractSignatureEncryptedPrivateKey>
            <DHpublickey>
    """
    certinstres = msgbody1.CertificateInstallationResType()
    certinstres.ResponseCode = msgbody1.responseCodeType.OK

    # Define the certificate chain types
    chain_types = [
        ("SAProvisioningCertificateChain", 2),
        ("ContractSignatureCertChain", 2)
    ]

    for chain_name, num_subcerts in chain_types:
        chain = msgbody1.CertificateChainType()
        chain.Certificate = b""

        subcertificates = msgdatatypes1.SubCertificatesType()
        for _ in range(num_subcerts):
            subcertificates.add_Certificate(b"")

        chain.SubCertificates = subcertificates
        setattr(certinstres, chain_name, chain)

    # ContractSignatureEncryptedPrivateKey
    certinstres.ContractSignatureEncryptedPrivateKey = msgdatatypes1.ContractSignatureEncryptedPrivateKeyType(
        valueOf_=b"")

    # DHpublickey
    certinstres.DHpublickey = msgdatatypes1.DiffieHellmanPublickeyType(valueOf_=b"")

    # eMAID
    certinstres.eMAID = msgdatatypes1.EMAIDType(valueOf_="DE1ABCD2EF357A")
    return certinstres


# def load_contract_certificates_to_xml(path, certinstres):
#     """Load the Contract pkcs12 file containing the contract private key, the contract
#     certificate and the certificate chain. Parse everything in the CertificateInstallationRes
#     (certinstres) element
#
#     Args:
#         path : Pathg of the contract  pkcs12 file
#         certinstres : CertificateInstallationRes element template to be filled
#     Returns:
#         CertificateInstallationRes element with <ContractSignatureCertChain> element filled
#     """
#     with open(path, 'rb') as pkcs12_file:
#         pkcs12_data = pkcs12_file.read()
#     pkcs12_password_bytes = "123456".encode('utf8')
#
#     # Returns a tuple where 0:privatekey, 1:certificate, 2:certificate_chain
#     mocertchain = load_key_and_certificates(pkcs12_data, pkcs12_password_bytes)
#     mosub1 = mocertchain[2][0].public_bytes(serialization.Encoding.PEM)
#     mosub2 = mocertchain[2][1].public_bytes(serialization.Encoding.PEM)
#     mocert = mocertchain[1].public_bytes(serialization.Encoding.PEM)
#     mosub2 = mosub2.split(b"-----")[2].strip()
#     mosub1 = mosub1.split(b"-----")[2].strip()
#     mocert = mocert.split(b"-----")[2].strip()
#
#     certinstres.ContractSignatureCertChain.Certificate = mocert
#     test = certinstres.ContractSignatureCertChain.get_SubCertificates()
#     test.replace_Certificate_at(0, mosub2)
#     test.replace_Certificate_at(1, mosub1)
#     return certinstres
# def load_cps_certificates_to_xml(path, certinstres):
#     """Load the CPS pkcs12 file containing the contract private key, the contract
#     certificate and the certificate chain. Parse everything in the CertificateInstallationRes
#     (certinstres) element
#
#     Args:
#         path : Pathg of the cps  pkcs12 file
#         certinstres : CertificateInstallationRes element template to be filled
#     Returns:
#         CertificateInstallationRes element with <SAProvisioningCertificateChain> element filled
#     """
#     with open(path, 'rb') as pkcs12_file:
#         pkcs12_data = pkcs12_file.read()
#     pkcs12_password_bytes = "123456".encode('utf8')
#
#     # Returns a tuple where 0:privatekey, 1:certificate, 2:certificate_chain
#     cpscertchain = load_key_and_certificates(pkcs12_data,
#                                              pkcs12_password_bytes)
#     cpssub1f = cpscertchain[2][0].public_bytes(serialization.Encoding.PEM)
#     cpssub2f = cpscertchain[2][1].public_bytes(serialization.Encoding.PEM)
#     cpscertf = cpscertchain[1].public_bytes(serialization.Encoding.PEM)
#     cpssub2 = cpssub2f.split(b"-----")[2].strip()
#     cpssub1 = cpssub1f.split(b"-----")[2].strip()
#     cpscert = cpscertf.split(b"-----")[2].strip()
#
#     certinstres.SAProvisioningCertificateChain.Certificate = cpscert
#     test = certinstres.SAProvisioningCertificateChain.get_SubCertificates()
#     test.replace_Certificate_at(0, cpssub2)
#     test.replace_Certificate_at(1, cpssub1)
#     return certinstres
# def load_contract_cert_key_eim(pathcert):
#     """In case of EIM no Contract Certificate Installation is needed. This methods loads
#     the contract certificate and its corresponding key and returns them to the evcc class
#     so they can be stored by the EV
#
#     Args:
#         pathcert (str): path to contract certificate pkcs12
#
#     """
#     with open(pathcert, 'rb') as pkcs12_file:
#         pkcs12_data = pkcs12_file.read()
#     pkcs12_password_bytes = "123456".encode('utf8')
#
#     # Returns a tuple where 0:privatekey, 1:certificate, 2:certificate_chain
#     mocertchain = load_key_and_certificates(pkcs12_data, pkcs12_password_bytes)
#     moprivatekey = mocertchain[0]
#     mosub1 = mocertchain[2][0].public_bytes(serialization.Encoding.PEM)
#     mosub2 = mocertchain[2][1].public_bytes(serialization.Encoding.PEM)
#     mocert = mocertchain[1].public_bytes(serialization.Encoding.PEM)
#     mosub2 = mosub2.split(b"-----")[2].strip()
#     mosub1 = mosub1.split(b"-----")[2].strip()
#     mocert = mocert.split(b"-----")[2].strip()
#     return mocert, moprivatekey

"""Changes made to the code:
Created the 'load_key_cert_chain' func to encapsulate the common logic of loading key, certificates, and extracting relevant information.
Imported the necessary module (serialization) directly.
Used b"123456" to directly represent the password as bytes.
Unpacked the values from mocertchain into meaningful variables (private_key, contract_cert, cert_chain) for better readability.
Created a list of PEM-encoded certificate chain elements (cert_chain_pems) using a list comprehension.
Removed duplicate variable assignments (mosub1, mosub2, mocert).
Simplified and clarified the certificate replacement in sub_certificates."""


def load_key_cert_chain(pkcs12_data, password):
    private_key, cert, cert_chain = load_key_and_certificates(pkcs12_data, password)
    cert_chain_pems = [c.public_bytes(serialization.Encoding.PEM).split(b"-----")[2].strip() for c in cert_chain]
    cert_pem = cert.public_bytes(serialization.Encoding.PEM).split(b"-----")[2].strip()
    return cert_pem, private_key, cert_chain_pems


def load_contract_certificates_to_xml(path, certinstres):
    with open(path, 'rb') as pkcs12_file:
        pkcs12_data = pkcs12_file.read()

    password_bytes = b"123456"
    cert_pem, _, cert_chain_pems = load_key_cert_chain(pkcs12_data, password_bytes)

    certinstres.ContractSignatureCertChain.Certificate = cert_pem

    sub_certificates = certinstres.ContractSignatureCertChain.get_SubCertificates()
    sub_certificates.replace_Certificate_at(0, cert_chain_pems[1])
    sub_certificates.replace_Certificate_at(1, cert_chain_pems[0])

    return certinstres


def load_cps_certificates_to_xml(path, certinstres):
    with open(path, 'rb') as pkcs12_file:
        pkcs12_data = pkcs12_file.read()

    password_bytes = b"123456"
    cert_pem, _, cert_chain_pems = load_key_cert_chain(pkcs12_data, password_bytes)

    certinstres.SAProvisioningCertificateChain.Certificate = cert_pem

    sub_certificates = certinstres.SAProvisioningCertificateChain.get_SubCertificates()
    sub_certificates.replace_Certificate_at(0, cert_chain_pems[1])
    sub_certificates.replace_Certificate_at(1, cert_chain_pems[0])

    return certinstres


def load_contract_cert_key_eim(pathcert):
    with open(pathcert, 'rb') as pkcs12_file:
        pkcs12_data = pkcs12_file.read()

    password_bytes = b"123456"
    cert_pem, private_key, _ = load_key_cert_chain(pkcs12_data, password_bytes)

    return cert_pem, private_key

def generate_dhpublickey_contractsignatureencryptedprivatekey(
        pathtooemprov, pathtocontractprivatekey, certinstres):
    """Method to Generate the DHpublickey and the ContractSignatureEncryptedPrivateKey elements.
    The process is being described in the comments

    Args:
        pathtooemprov : Path to the OEM provisioning certificate. Its public key
        will be used for the ECDH exchange method
        pathtocontractprivatekey (_type_): Path to the contract private key. It will be
        used for the ECDH exchange method with oem
        public key
        certinstres: CertificateInstallationRes with <ContractSignatureCertChain> and <SAProvisioningCertificateChain>  filled

    Returns:
        CertificateInstallationRes element with all elements filled
    """
    # Generating an ephemeral key pair from the ECC domain parameters of the named curve
    # ”secp256r1” (the public key part is the above mentioned DHpublickey),
    dh_private_key = ec.generate_private_key(ec.SECP256R1())
    dh_public_key = dh_private_key.public_key()

    # Generating a shared secret which is computed using the domain parameters of the named
    # curve ”secp256r1”, the private key part of the ephemeral key pair generated in the previous
    # step, and the OEM provisioning certificate’s public key,

    # OEM provisioning certificate public key
    _f = open(pathtooemprov, "rb")
    oemprov = _f.read()
    oemprov = x509.load_pem_x509_certificate(oemprov)
    oemprov_public_key = oemprov.public_key()
    session_key = dh_private_key.exchange(ec.ECDH(), oemprov_public_key)

    # Using this shared secret as input for an agreed-upon key derivation function  in order to
    # derive the 128 bit session key
    derived_key = HKDF(
        algorithm=hashes.SHA256(),
        length=16,
        salt=None,
        info=b'handshake data',
    ).derive(session_key)

    # Contract Private key
    _f = open(pathtocontractprivatekey, "rb")
    contract_private_key = _f.read()

    # Encrypting with AES
    contractSignatureEncryptedPrivateKey = aes_encrypt(derived_key,
                                                       contract_private_key)
    contractSignatureEncryptedPrivateKey = base64.b64encode(
        contractSignatureEncryptedPrivateKey).decode('utf-8')

    # Setting ContractSignatureEncryptedPrivateKey and DHpublickey to their respectable values
    dh_public_key = dh_public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo)

    dh_public_key = dh_public_key.split(b"-----")[2].strip()
    certinstres.ContractSignatureEncryptedPrivateKey = msgdatatypes1.ContractSignatureEncryptedPrivateKeyType(
        valueOf_=contractSignatureEncryptedPrivateKey)
    certinstres.DHpublickey = msgdatatypes1.DiffieHellmanPublickeyType(
        valueOf_=dh_public_key.decode('utf-8'))
    return certinstres


# def attach_reference_identifiers(v2gmessage):
#     """Generates the Unique Identifiers for the fields that will be signed.
#
#
#     Args:
#         v2gmessage : The whole V2G Message.
#
#     Returns:
#         v2gmessage : The whole V2g Message with the Unique Identifiers added.
#     """
#     bodypart = v2gmessage.get_Body().BodyElement
#     # Check for messagetype and attach IDS Accordingly
#     if (bodypart.original_tagname_ == "CertificateInstallationReq"
#             or bodypart.original_tagname_ == "AuthorizationReq"
#             or bodypart.original_tagname_ == "MeteringReceiptReq"):
#         bodypart.set_Id("id1")
#     if bodypart.original_tagname_ == "CertificateInstallationRes":
#         bodypart.ContractSignatureCertChain.set_Id("id1")
#         bodypart.ContractSignatureEncryptedPrivateKey.set_Id("id2")
#         bodypart.DHpublickey.set_Id("id3")
#         bodypart.eMAID.set_Id("id4")
#
#     bodyelement = msgDef1.BodyType(bodypart)
#
#     v2gmessage.set_Body(bodyelement)
#     return v2gmessage

""" use of 'tag_to_id_mapping' dictionary to map tag names to unique identifier IDs or to nested dictionaries specifying field-to-ID mappings,
    so as to reduce code repetition and improves maintainability."""

def attach_reference_identifiers(v2gmessage):
    """Generates the Unique Identifiers for the fields that will be signed.

    Args:
        v2gmessage : The whole V2G Message.

    Returns:
        v2gmessage : The whole V2g Message with the Unique Identifiers added.
    """
    bodypart = v2gmessage.get_Body().BodyElement
    tag_to_id_mapping = {
        "CertificateInstallationReq": "id1",
        "AuthorizationReq": "id1",
        "MeteringReceiptReq": "id1",
        "CertificateInstallationRes": {
            "ContractSignatureCertChain": "id1",
            "ContractSignatureEncryptedPrivateKey": "id2",
            "DHpublickey": "id3",
            "eMAID": "id4"
        }
    }

    tagname = bodypart.original_tagname_
    if tagname in tag_to_id_mapping:
        id_mapping = tag_to_id_mapping[tagname]
        if isinstance(id_mapping, str):
            bodypart.set_Id(id_mapping)
        else:
            for field, id_value in id_mapping.items():
                setattr(getattr(bodypart, field), "Id", id_value)

    bodyelement = msgDef1.BodyType(bodypart)
    v2gmessage.set_Body(bodyelement)
    return v2gmessage


def sign_authorization_req_message(v2gmessage, contract_private_key):
    """Signs AuthorizationReq message. Will be signed by EVCC with private key
    belonging to contract certificate. Complete message body will be signed


    Args:
        v2gmessage : The original unsigned AuthorizationReq message
        contract_private_key : The private key corresponding to the contract certificate

    Returns:
        Signed AuthorizationReq message
    """

    digest_value = generate_authorization_req_digest_value(v2gmessage)
    signature = generate_CertInstallReq_AuthorizationReq_MeteringReceiptReq_SignedInfo(
        digest_value)
    header = v2gmessage.get_Header()
    header.Signature = signature

    # Transform Signed Info to EXI and encrypt using oem_private_key with sha256
    signed_info = signature.SignedInfo

    with open('common/EXI_Files/testresres.xml', 'w') as outfile:
        signed_info.export(outfile=outfile, level=0, name_='SignedInfo')
    java_caller.xml_to_binary('common/EXI_Files/testresres.xml',
                              'common/EXI_Files/test1_xml.exi')

    #_f = open("common/EXI_Files/test1_xml.exi", "rb")
    # exi2 = _f.read()
    with open("common/EXI_Files/test1_xml.exi", "rb") as exi_file:
        exi2 = exi_file.read()
    encrypted_has_value = contract_private_key.sign(exi2, ec.ECDSA(hashes.SHA256()))

    # To Base64
    signaturevalue = base64.b64encode(encrypted_has_value)

    signature.set_SignatureValue(
        msgheader1.SignatureValueType(valueOf_=signaturevalue.decode('utf-8')))
    v2gmessage.set_Header(header)

    # Verifying Signature (For Testing Porpuses)
    evcc_public_key = contract_private_key.public_key()
    signaturevalue2 = base64.b64decode(signaturevalue)
    evcc_public_key.verify(signaturevalue2, exi2, ec.ECDSA(hashes.SHA256()))
    return v2gmessage


def sign_certinstallreq_message(v2gmessage, oem_prov_private_key):
    """Signs CertInstallReq,  message.
    Will be signed by EVCC with private key
    belonging to the OEM prov certificate. Complete message body will be signed


    Args:
        v2gmessage : The original unsigned AuthorizationReq message
        oem_private_key : The private key corresponding to the contract certificate

    Returns:
        Signed AuthorizationReq message
    """
    bodypart = v2gmessage.get_Body().BodyElement

    digest_value = generate_cert_install_req_digest_value(
        v2gmessage, bodypart.original_tagname_)

    signature = generate_CertInstallReq_AuthorizationReq_MeteringReceiptReq_SignedInfo(
        digest_value)
    header = v2gmessage.get_Header()

    header.Signature = signature

    # Transform Signed Info to EXI and encrypt using oem_private_key with sha256
    signed_info = signature.SignedInfo

    with open('common/EXI_Files/testresres.xml', 'w') as outfile:
        signed_info.export(outfile=outfile, level=0, name_='SignedInfo')
    java_caller.xml_to_binary('common/EXI_Files/testresres.xml',
                              'common/EXI_Files/test1_xml.exi')
    _f = open("common/EXI_Files/test1_xml.exi", "rb")
    exi2 = _f.read()
    encrypted_has_value = oem_prov_private_key.sign(exi2, ec.ECDSA(hashes.SHA256()))

    # To Base64
    signaturevalue = base64.b64encode(encrypted_has_value)

    signature.set_SignatureValue(
        msgheader1.SignatureValueType(valueOf_=signaturevalue.decode('utf-8')))
    v2gmessage.set_Header(header)

    # Verifying Signature (For Testing Porpuses)
    evcc_public_key = oem_prov_private_key.public_key()
    signaturevalue2 = base64.b64decode(signaturevalue)
    evcc_public_key.verify(signaturevalue2, exi2, ec.ECDSA(hashes.SHA256()))

    return (v2gmessage)


def sign_metering_receipt_req_message(v2gmessage, contract_private_key):
    """Signs MeteringReceiptReq. Will be signed by EVCC with private key
    belonging to the Contract Certificate. Complete message body will be signed


    Args:
        v2gmessage : The original unsigned MeteringReceiptReq message
        contract_private_key : The private key corresponding to the contract certificate

    Returns:
        Signed AuthorizationReq message
    """

    digestvalues = generate_metering_receipt_req_digest_value(v2gmessage)
    signature = generate_CertInstallReq_AuthorizationReq_MeteringReceiptReq_SignedInfo(
        digestvalues)

    header = v2gmessage.get_Header()
    header.Signature = signature

    signed_info = signature.SignedInfo

    with open('common/EXI_Files/testresres.xml', 'w') as outfile:
        signed_info.export(outfile=outfile, level=0, name_='SignedInfo')
    java_caller.xml_to_binary('common/EXI_Files/testresres.xml',
                              'common/EXI_Files/test1_xml.exi')
    _f = open("common/EXI_Files/test1_xml.exi", "rb")
    exi2 = _f.read()

    encrypted_has_value = contract_private_key.sign(exi2,
                                                    ec.ECDSA(hashes.SHA256()))
    # To Base64
    signaturevalue = base64.b64encode(encrypted_has_value)

    signature.set_SignatureValue(
        msgheader1.SignatureValueType(valueOf_=signaturevalue.decode('utf-8')))

    v2gmessage.set_Header(header)

    return v2gmessage


def sign_cert_install_res_message(v2gmessage, cpsSubCA2_private_key_path):
    bodypart = v2gmessage.get_Body().BodyElement
    digestvalues = generate_cert_install_res_digest_values(bodypart)
    signature = generate_cert_install_res_signed_info(digestvalues)
    header = v2gmessage.get_Header()
    header.Signature = signature

    # Transform Signed Info to EXI and encrypt using oem_private_key with sha256
    signed_info = signature.SignedInfo

    with open('common/EXI_Files/testresres.xml', 'w') as outfile:
        signed_info.export(outfile=outfile, level=0, name_='SignedInfo')
    java_caller.xml_to_binary('common/EXI_Files/testresres.xml',
                              'common/EXI_Files/test1_xml.exi')
    _f = open("common/EXI_Files/test1_xml.exi", "rb")
    exi2 = _f.read()

    # Load cpsSUBCA2 private key
    _f = open(cpsSubCA2_private_key_path, "rb")
    cpsSubCA2_private_key = _f.read()

    cpsSubCA2_private_key = load_pem_private_key(cpsSubCA2_private_key,
                                                 b'123456')

    encrypted_has_value = cpsSubCA2_private_key.sign(exi2,
                                                     ec.ECDSA(hashes.SHA256()))

    # To Base64
    signaturevalue = base64.b64encode(encrypted_has_value)

    signature.set_SignatureValue(
        msgheader1.SignatureValueType(valueOf_=signaturevalue.decode('utf-8')))
    v2gmessage.set_Header(header)

    return v2gmessage



def generate_authorization_req_digest_value(v2gmessage):
    # 1.1 Generate EXI of the element
    bodypart = v2gmessage.get_Body().BodyElement
    with open('common/EXI_Files/final.xml', 'w') as outfile:
        bodypart.export(outfile=outfile, level=0, name_='AuthorizationReq')

    java_caller.xml_to_binary('common/EXI_Files/final.xml', 'common/EXI_Files/final_xml.exi')
    _f = open("common/EXI_Files/final_xml.exi", "rb")
    exi = _f.read()
    _f.close()

    # 1.2 Exi to SHA-256 to Base64
    digestvalue = base64.b64encode(hashlib.sha256(exi).digest())
    return digestvalue


def generate_metering_receipt_req_digest_value(v2gmessage):
    # 1.1 Generate EXI of the element
    bodypart = v2gmessage.get_Body().BodyElement
    with open('common/EXI_Files/final.xml', 'w') as outfile:
        bodypart.export(outfile=outfile, level=0, name_='MeteringReceiptReq')

    java_caller.xml_to_binary('EXI_Files/final.xml', 'EXI_Files/final_xml.exi')
    _f = open("common/EXI_Files/final_xml.exi", "rb")
    exi = _f.read()
    _f.close()

    # 1.2 Exi to SHA-256 to Base64
    digestvalue = base64.b64encode(hashlib.sha256(exi).digest())
    return digestvalue


def generate_cert_install_req_digest_value(v2gmessage, tagname):
    # 1.1 Generate EXI of the element
    bodypart = v2gmessage.get_Body().BodyElement
    with open('common/EXI_Files/final.xml', 'w') as outfile:
        bodypart.export(outfile=outfile, level=0, name_=tagname)

    java_caller.xml_to_binary('common/EXI_Files/final.xml', 'common/EXI_Files/final_xml.exi')
    _f = open("common/EXI_Files/final_xml.exi", "rb")
    exi = _f.read()
    _f.close()

    # 1.2 Exi to SHA-256 to Base64
    digestvalue = base64.b64encode(hashlib.sha256(exi).digest())

    return digestvalue


def generate_cert_install_res_digest_values(certinstres):
    # ID1 ContractSignatureCertChain
    # To EXI
    contsigchain = certinstres.ContractSignatureCertChain
    with open('common/EXI_Files/ContractSignatureCertChain.xml', 'w') as outfile:
        contsigchain.export(outfile=outfile,
                            level=0,
                            name_='ContractSignatureCertChain')
    java_caller.xml_to_binary('common/EXI_Files/ContractSignatureCertChain.xml',
                              'common/EXI_Files/ContractSignatureCertChain_xml.exi')
    _f = open("common/EXI_Files/ContractSignatureCertChain_xml.exi", "rb")
    exi = _f.read()
    # To digest value
    digestvalue1 = base64.b64encode(hashlib.sha256(exi).digest())
    # ID2 ContractSignatureEncryptedPrivateKey
    # To EXI
    consigencpri = certinstres.ContractSignatureEncryptedPrivateKey
    with open('common/EXI_Files/ContractSignatureEncryptedPrivateKey.xml',
              'w') as outfile:
        consigencpri.export(outfile=outfile,
                            level=0,
                            name_='ContractSignatureEncryptedPrivateKey')
    java_caller.xml_to_binary(
        'common/EXI_Files/ContractSignatureEncryptedPrivateKey.xml',
        'common/EXI_Files/ContractSignatureEncryptedPrivateKey_xml.exi')
    _f = open("common/EXI_Files/ContractSignatureEncryptedPrivateKey_xml.exi", "rb")
    exi2 = _f.read()
    # To digest value
    digestvalue2 = base64.b64encode(hashlib.sha256(exi2).digest())

    # ID4 eMAID
    # To EXI
    emaid = certinstres.eMAID
    with open('common/EXI_Files/eMAID.xml', 'w') as outfile:
        emaid.export(outfile=outfile, level=0, name_='eMAID')
    java_caller.xml_to_binary('common/EXI_Files/eMAID.xml', 'common/EXI_Files/eMAID_xml.exi')
    _f = open("common/EXI_Files/eMAID_xml.exi", "rb")
    exi4 = _f.read()
    # To digest value
    digestvalue4 = base64.b64encode(hashlib.sha256(exi4).digest())

    # ID3 DHpublicKey
    # To EXI
    DHpublickey = certinstres.DHpublickey
    with open('common/EXI_Files/DHpublickey.xml', 'w') as outfile:
        DHpublickey.export(outfile=outfile, level=0, name_='DHpublickey')
    java_caller.xml_to_binary('common/EXI_Files/DHpublickey.xml',
                              'common/EXI_Files/DHpublickey_xml.exi')
    _f = open("common/EXI_Files/DHpublickey_xml.exi", "rb")
    exi3 = _f.read()
    # To digest value
    digestvalue3 = base64.b64encode(hashlib.sha256(exi3).digest())

    digestvalues = {
        'ContractSignatureCertChain': digestvalue1,
        'ContractSignatureEncryptedPrivateKey': digestvalue2,
        'eMAID': digestvalue4,
        'DHpublicKey': digestvalue3
    }
    return digestvalues


def generate_CertInstallReq_AuthorizationReq_MeteringReceiptReq_SignedInfo(
        digest_value):
    """Generates CertInstallReq, AuthorizationReq, MeteringReceiptReq Signed info
     In this specific case only the body will be signed so we only have
    one reference element.



    Args:
        digest_value : The digest value that was generated by digest value generation methods


    Returns:
       The Signature element containing the SignedInfo element
    """
    canmet = msgxmlschema1.CanonicalizationMethodType()
    canmet.Algorithm = "http://www.w3.org/TR/canonical-exi/"

    sigmet = msgxmlschema1.SignatureMethodType(
        Algorithm="http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256")
    tran = msgxmlschema1.TransformType(
        Algorithm="http://www.w3.org/TR/canonical-exi/")
    dig = msgxmlschema1.DigestMethodType(
        Algorithm="http://www.w3.org/2001/04/xmlenc#sha256")

    trans = msgxmlschema1.TransformsType()
    trans.add_Transform(tran)
    digv = msgxmlschema1.DigestValueType("")

    ref = msgxmlschema1.ReferenceType(Transforms=trans,
                                      DigestMethod=dig,
                                      DigestValue=digv)
    ref.URI = "#ID1"
    ref.set_DigestValue(
        msgxmlschema1.DigestValueType(digest_value.decode("utf-8")))

    siginf = msgxmlschema1.SignedInfoType(CanonicalizationMethod=canmet,
                                          SignatureMethod=sigmet)
    siginf.add_Reference(ref)

    signature = msgxmlschema1.SignatureType()
    signature.SignedInfo = siginf

    return signature


def generate_cert_install_res_signed_info(digest_values):
    # Creating Signed Info
    canmet = msgxmlschema1.CanonicalizationMethodType()
    canmet.Algorithm = "http://www.w3.org/TR/canonical-exi/"
    sigmet = msgxmlschema1.SignatureMethodType(
        Algorithm="http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256")
    tran = msgxmlschema1.TransformType(
        Algorithm="http://www.w3.org/TR/canonical-exi/")
    dig = msgxmlschema1.DigestMethodType(
        Algorithm="http://www.w3.org/2001/04/xmlenc#sha256")
    trans = msgxmlschema1.TransformsType()
    trans.add_Transform(tran)

    digv = msgxmlschema1.DigestValueType("")

    ref2 = msgxmlschema1.ReferenceType(Transforms=trans,
                                       DigestMethod=dig,
                                       DigestValue=digv)
    ref2.URI = "#id2"

    ref1 = msgxmlschema1.ReferenceType(Transforms=trans,
                                       DigestMethod=dig,
                                       DigestValue=digv)
    ref1.URI = "#id1"

    ref4 = msgxmlschema1.ReferenceType(Transforms=trans,
                                       DigestMethod=dig,
                                       DigestValue=digv)
    ref4.URI = "#id4"

    ref3 = msgxmlschema1.ReferenceType(Transforms=trans,
                                       DigestMethod=dig,
                                       DigestValue=digv)
    ref3.URI = "#id3"
    siginf = msgxmlschema1.SignedInfoType(CanonicalizationMethod=canmet,
                                          SignatureMethod=sigmet)
    siginf.add_Reference(ref2)
    siginf.add_Reference(ref1)
    siginf.add_Reference(ref4)
    siginf.add_Reference(ref3)

    digestvalue1 = digest_values['ContractSignatureCertChain']
    digestvalue2 = digest_values['ContractSignatureEncryptedPrivateKey']
    digestvalue4 = digest_values['eMAID']
    digestvalue3 = digest_values['DHpublicKey']

    siginf.Reference[1].set_DigestValue(
        msgxmlschema1.DigestValueType(valueOf_=digestvalue1.decode('utf-8')))
    siginf.Reference[0].set_DigestValue(
        msgxmlschema1.DigestValueType(valueOf_=digestvalue2.decode('utf-8')))
    siginf.Reference[2].set_DigestValue(
        msgxmlschema1.DigestValueType(valueOf_=digestvalue4.decode('utf-8')))
    siginf.Reference[3].set_DigestValue(
        msgxmlschema1.DigestValueType(valueOf_=digestvalue3.decode('utf-8')))

    signature = msgxmlschema1.SignatureType()
    signature.SignedInfo = siginf

    return signature


def verify_certificate_installation_req(msg):
    """Verifies CertificateInstallationReq Message. CertificateInstallationReq is being signed by
    OEM prov private key corresponding to the OEM prov certificate. The Secondary actor (CPS) verifies
    with the OEM prov public key corresponding to the OEM prov certificate

    Args:
         msg: CertificateInstallationReq msg
    """
    # Getting EXI Message
    testexi = msg.get_Header().get_Signature().get_SignedInfo()
    with open('common/EXI_Files/installationreq.xml', 'w') as outfile:
        testexi.export(outfile=outfile, level=0, name_='SignedInfo')
    java_caller.xml_to_binary('common/EXI_Files/installationreq.xml',
                              'common/EXI_Files/installationreq.xml.exi')
    _f = open("common/EXI_Files/installationreq.xml.exi", "rb")
    exi3 = _f.read()

    # Getting Signature of Message
    signaturevalue = msg.get_Header().get_Signature().get_SignatureValue(
    ).valueOf_
    signaturevalue = base64.b64decode(signaturevalue)

    # Getting Public Key
    bodypart = msg.get_Body().BodyElement.get_OEMProvisioningCert()
    _s = bodypart.decode('utf-8')
    _s = '-----BEGIN CERTIFICATE-----\n' + _s + '\n-----END CERTIFICATE-----\n'

    certfinal = x509.load_pem_x509_certificate(_s.encode())
    evcc_public_key = certfinal.public_key()

    # Verifying Signature
    evcc_public_key.verify(signaturevalue, exi3, ec.ECDSA(hashes.SHA256()))

    print("CertificateInstallationReq Signature Verified!")


def verify_certificate_installation_res(msg):
    """Verifies verify_certificate_installation_res Message. CertificateInstallationRes
    is being signed by CPS (Secondary actor) with the private key of its Sub-CA 2. EVCC verifies
    with the  public key corresponding to the Sub-CA 2 CPS certificate

    Args:
         msg: CertificateInstallationRes msg
    """
    # Getting EXI Message
    testexi = msg.get_Header().get_Signature().get_SignedInfo()
    with open('common/EXI_Files/installationres.xml', 'w') as outfile:
        testexi.export(outfile=outfile, level=0, name_='SignedInfo')
    java_caller.xml_to_binary('common/EXI_Files/installationres.xml',
                              'common/EXI_Files/installationres.xml.exi')
    _f = open("common/EXI_Files/installationres.xml.exi", "rb")
    exi3 = _f.read()

    # Getting Signature of Message
    signaturevalue = msg.get_Header().get_Signature().get_SignatureValue(
    ).valueOf_
    signaturevalue = base64.b64decode(signaturevalue)

    # Getting Public Key
    bodypart = msg.get_Body(
    ).BodyElement.SAProvisioningCertificateChain.get_SubCertificates(
    ).Certificate[1]
    _s = bodypart.decode('utf-8')
    _s = '-----BEGIN CERTIFICATE-----\n' + _s + '\n-----END CERTIFICATE-----\n'

    certfinal = x509.load_pem_x509_certificate(_s.encode())
    cpssubca2_public_key = certfinal.public_key()

    # Verifying Signature
    cpssubca2_public_key.verify(signaturevalue, exi3,
                                ec.ECDSA(hashes.SHA256()))

    print("CertificateInstallationReq Signature Verified!")


def verify_metering_receipt_req(msg, contract_cert):
    """Verifies MeteringReceiptReq Message. MeteringReceiptReq is being signed by
    EVCC with the private key corresponding the Contract certificate. SECC verifies
    with the  public key corresponding to the Contract certificate

    Args:
         msg: MeteringReceiptReq msg
    """
    # Getting EXI Message
    testexi = msg.get_Header().get_Signature().get_SignedInfo()
    with open('common/EXI_Files/testpaps.xml', 'w') as outfile:
        testexi.export(outfile=outfile, level=0, name_='SignedInfo')
    java_caller.xml_to_binary('common/EXI_Files/testpaps.xml',
                              'common/EXI_Files/testpaps_xml.exi')
    _f = open("common/EXI_Files/testpaps_xml.exi", "rb")
    exi3 = _f.read()

    # Getting Signature of Message
    signaturevalue = msg.get_Header().get_Signature().get_SignatureValue(
    ).valueOf_
    signaturevalue = base64.b64decode(signaturevalue)

    contract_public_key = contract_cert.public_key()

    # Verifying Signature
    contract_public_key.verify(signaturevalue, exi3, ec.ECDSA(hashes.SHA256()))

    print("verify_metering_receipt_req Signature Verified!")
    return True


def verify_authorization_req(msg, contract_cert):
    """Verifies AuthorizationReq message. The public key of the contract certificate
    installed by CertificateInstallationRes will be used to verify th

    Args:
        msg : AuthorizationReq message
        contract_cert : Contract certificate
    """
    # Getting EXI Message
    testexi = msg.get_Header().get_Signature().get_SignedInfo()
    with open('common/EXI_Files/testpaps.xml', 'w') as outfile:
        testexi.export(outfile=outfile, level=0, name_='SignedInfo')
    java_caller.xml_to_binary('common/EXI_Files/testpaps.xml',
                              'common/EXI_Files/testpaps_xml.exi')
    _f = open("common/EXI_Files/testpaps_xml.exi", "rb")
    exi3 = _f.read()

    # Getting Signature of Message
    signaturevalue = msg.get_Header().get_Signature().get_SignatureValue(
    ).valueOf_
    signaturevalue = base64.b64decode(signaturevalue)

    contract_public_key = contract_cert.public_key()
    # Verifying Signature
    contract_public_key.verify(signaturevalue, exi3, ec.ECDSA(hashes.SHA256()))

    print("AuthorizationReq Signature Verified!")


def load_pem_certificate(_s):
    """Loads a cryptography library PEM public certificate object

    Args:
        s (bytes): Payload of the public key

    Returns:
        PEM public key object
    """

    _s = _s.decode('utf-8')
    _s = '-----BEGIN CERTIFICATE-----\n' + str(
        _s) + '\n-----END CERTIFICATE-----\n'

    certfinal = x509.load_pem_x509_certificate(_s.encode())
    return certfinal


def load_pem_public_key_formatted(_s):
    """Loads a cryptography library PEM public key object

    Args:
        s (bytes): Payload of the public key

    Returns:
        PEM public key object
    """
    _s = '-----BEGIN PUBLIC KEY-----\n' + _s + '\n-----END PUBLIC KEY-----\n'

    public_key = load_pem_public_key(_s.encode())
    return public_key


def decrypt_contract_private_key(message, oemprovkey):
    """Parses the CertificateInstallationRes message and based on its element values decrypts
    and generates the contract private key

    Args:
        message : CertificateInstallationRes message

    Returns:
        ContractPrivatekey cryptography object
    """
    # Storing Contract Certificate
    # contract_cert_text = message.get_Body(
    # ).BodyElement.ContractSignatureCertChain.Certificate

    # Storing Contract Certificate Private Key
    contract_private_key_text = message.get_Body(
    ).BodyElement.ContractSignatureEncryptedPrivateKey.valueOf_

    # Getting DH Public Key
    dh_public_key_text = message.get_Body().BodyElement.DHpublickey.valueOf_
    dh_public_key = load_pem_public_key_formatted(dh_public_key_text)

    # It calculates the session key as described above with the OEM provisioning
    # certificate’s private key and the DHpublickey parameter.
    oem_private_key = load_private_key(oemprovkey)
    session_key = oem_private_key.exchange(ec.ECDH(), dh_public_key)

    derived_key = HKDF(
        algorithm=hashes.SHA256(),
        length=16,
        salt=None,
        info=b'handshake data',
    ).derive(session_key)

    # ContractPrivateKey
    contract_privateKey = aes_decrypt(derived_key, contract_private_key_text)
    contract_privateKey = contract_privateKey.replace(contract_privateKey[:16],
                                                      b'-----BEGIN EC PR')
    # Load ContractPrivateKey Object
    contract_privateKey = load_pem_private_key(contract_privateKey, b'123456')

    return contract_privateKey


def generate_gen_challenge():
    """Generates the genChallenge that will be used in PaymentDetailsRes
    and AuthorizationReq Messages

    Returns:
        bytes: base64Binary with length of 16
    """
    gen = base64.b16encode(random.getrandbits(
        128).to_bytes(16, byteorder='little'))
    return gen


def generate_session_id():
    """Generates the SessionID

    Returns:
        hexBinary with max length: 8
    """
    return ('%016x' % random.randrange(16 ** 16)).upper()