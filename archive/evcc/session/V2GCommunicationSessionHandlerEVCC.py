#######################################################
# 
# V2GCommunicationSessionHandlerEVCC.py
# Python implementation of the Class V2GCommunicationSessionHandlerEVCC
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:10:45
# Original author: Fabian.Stichtenoth
# 
#######################################################
import logging
import socket
from typing import List
import ipaddress
from threading import Thread

from evcc.transportLayer.StatefulTransportLayerClient import StatefulTransportLayerClient
from evcc.transportLayer.UDPClient import UDPClient
from evcc.transportLayer.TLSClient import TLSClient
from evcc.transportLayer.TCPClient import TCPClient
from evcc.session.V2GCommunicationSessionEVCC import V2GCommunicationSessionEVCC
from shared.misc.V2GTPMessage import V2GTPMessage
from shared.misc.TimeRestrictions import TimeRestrictions
from shared.v2gMessages.SECCDiscoveryRes import SECCDiscoveryRes
from shared.v2gMessages.SECCDiscoveryReq import SECCDiscoveryReq
from shared.v2gMessages.appProtocol.AppProtocolType import AppProtocolType
from shared.v2gMessages.appProtocol.SupportedAppProtocolReq import SupportedAppProtocolReq
from shared.messageHandling.MessageHandler import MessageHandler
from shared.messageHandling.TerminateSession import TerminateSession
from shared.messageHandling.PauseSession import PauseSession
from shared.utils.MiscUtils import MiscUtils
from shared.enumerations.GlobalValues import GlobalValues
from shared.enumerations.V2GMessages import V2GMessages


class V2GCommunicationSessionHandlerEVCC:

    def __init__(self):
        self._message_handler = None
        self._secc_discovery_request_counter = 0
        self._session_retry_counter = 0
        self._security = b''
        self._v2g_communication_session_evcc = None
        self._v2g_tp_message = None
        self._transport_layer_thread = None
        self._transport_layer_client = None

        self.set_message_handler(MessageHandler())

        if MiscUtils.get_property_value("tls") is not None:
            sec = MiscUtils.get_property_value("tls")

        else:
            sec = GlobalValues.V2G_SECURITY_WITHOUT_TLS.get_byte_value()

        self.set_security(sec)

        self.set_session_retry_counter(0)

        self.__initialize()

    def get_message_handler(self) -> MessageHandler:
        """
        Returns the message handler
        :return _message_handler: MessageHandler
        """
        return self._message_handler

    def get_secc_discovery_request_counter(self) -> int:
        """
        Returns the secc discovery request counter
        :return _secc_discovery_request_counter: int
        """
        return self._secc_discovery_request_counter

    def get_security(self) -> bytes:
        """
        Returns the security value of type bytes
        :return _security: bytes
        """
        return self._security

    def get_session_retry_counter(self) -> int:
        return self._session_retry_counter

    def get_transport_layer_client(self):
        """
        Returns the transport layer client
        :return _transport_layer_client:
        """
        return self._transport_layer_client

    def get_transport_layer_thread(self):
        """
        Returns the transport layer thread
        :return _transport_layer_thread:
        """
        return self._transport_layer_thread

    def get_v2g_communication_session_evcc(self) -> V2GCommunicationSessionEVCC:
        """
        Returns the evcc-sided communication session
        :return _v2g_communication_session_evcc: V2GCommunicationSessionEVCC
        """
        return self._v2g_communication_session_evcc

    def get_v2g_tp_message(self) -> V2GTPMessage:
        """
        Returns the V2G-TransportProtocol-Message
        :return _v2g_tp_message:
        """
        return self._v2g_tp_message

    def __initialize(self) -> bool:
        """
        Initializes new UDP client, adjusts SECCDiscoveryRequestCounter, initiates sending of SECCDiscoveryReq and if
        correct response is returned, starts new session
        :return: bool that indicates true when session was started successfully and false otherwise
        """
        udp_client = UDPClient.get_instance()
        udp_client.initialize()

        secc_discovery_res = None
        self.set_session_retry_counter(self.get_secc_discovery_request_counter() + 1)

        while self.get_secc_discovery_request_counter() < TimeRestrictions.SDP_REQUEST_MAX_COUNTER:
            udp_response = self.__send_secc_discovery_req(self.get_security())

            if udp_response is None:
                logging.warning(
                    "Number of SECCDiscoveryReq messages so far: " + str(self.get_secc_discovery_request_counter()))

            else:
                self.set_v2g_tp_message(V2GTPMessage(udp_response))

                if self.get_message_handler().is_v2g_tp_message_valid(self.get_v2g_tp_message()):
                    secc_discovery_res = SECCDiscoveryRes(self.get_v2g_tp_message().get_payload())
                    break

                else:
                    continue

        if self.__start_new_session(secc_discovery_res):
            return True

        else:
            return False

    def is_secure_communication(self) -> bool:
        """
        Checks if the security of communication is correct
        :return: bool that indicates true when security is correct and false otherwise
        """
        if self.get_security().decode("utf8") == GlobalValues.V2G_SECURITY_WITH_TLS.get_byte_value().decode("utf8"):
            return True

        else:
            return False

    def __send_secc_discovery_req(self, security: bytes) -> bytes:
        """
        Prepares SECCDiscoveryReq, adjust SECCDiscoveryRequestCounter and initiates sending of the message
        :param security: bytes
        :return: bytes that express message that should be sent
        """
        secc_discovery_req = SECCDiscoveryReq(security, GlobalValues.V2G_TRANSPORT_PROTOCOL_TCP.get_byte_value())

        self.set_v2g_tp_message(V2GTPMessage(GlobalValues.V2GTP_VERSION_1_IS.get_byte_value(),
                                             GlobalValues.V2GTP_PAYLOAD_TYPE_SDP_REQUEST_MESSAGE.get_byte_array_value(),
                                             secc_discovery_req.get_payload()))

        logging.debug("Preparing to send SECCDiscoveryReq ...")
        self.set_secc_discovery_request_counter(self.get_secc_discovery_request_counter() + 1)

        return UDPClient.get_instance().send(self.get_v2g_tp_message())

    def __send_supported_app_protocol_req(self) -> None:
        """All supported versions of the ISO/IEC 15118-2 protocol are listed here.
        Currently, only IS version of April 2014 is supported (see [V2G2-098]), more
        could be provided here.
        :return: None
        """
        supported_app_protocols: List[AppProtocolType] = []

        app_protocol_1 = AppProtocolType()
        app_protocol_1.set_protocol_namespace(str(GlobalValues.V2G_CI_MSG_DEF_NAMESPACE))
        app_protocol_1.set_version_number_major(2)
        app_protocol_1.set_version_number_minor(0)
        app_protocol_1.set_schema_id(10)
        app_protocol_1.set_priority(1)

        supported_app_protocols.append(app_protocol_1)

        supported_app_protocol_req = SupportedAppProtocolReq()
        supported_app_protocol_req.get_app_protocol().append(app_protocol_1)

        self.get_v2g_communication_session_evcc().set_supported_app_protocols(supported_app_protocols)

        self.set_v2g_tp_message(V2GTPMessage(
            GlobalValues.V2GTP_VERSION_1_IS.get_byte_value(),
            GlobalValues.V2GTP_PAYLOAD_TYPE_EXI_ENCODED_V2G_MESSAGE.get_byte_array_value(),
            self.get_message_handler().supp_app_protocol_msg_to_exi(supported_app_protocol_req)))

        logging.debug("Preparing to send SupportedAppProtocolReq ...")

        if self.is_secure_communication():
            TLSClient.get_instance().send(self.get_v2g_tp_message(), TimeRestrictions.get_v2g_evcc_msg_timeout(
                V2GMessages.SUPPORTED_APP_PROTOCOL_RES))

        else:
            TCPClient.get_instance().send(self.get_v2g_tp_message(), TimeRestrictions.get_v2g_evcc_msg_timeout(
                V2GMessages.SUPPORTED_APP_PROTOCOL_RES))

    def set_message_handler(self, message_handler: MessageHandler) -> None:
        """
        Sets the message handler
        :param message_handler: MessageHandler
        :return: None
        """
        self._message_handler = message_handler

    def set_secc_discovery_request_counter(self, secc_discovery_request_counter: int) -> None:
        """
        Sets the SECCDiscoveryRequestCounter
        :param secc_discovery_request_counter: int
        :return: None
        """
        self._secc_discovery_request_counter = secc_discovery_request_counter

    def set_security(self, security: bytes) -> None:
        """
        Sets the security level, checks if it is TCP or TLS and logs the information
        :param security: bytes
        :return: None
        """
        self._security = security

        if security.decode("utf8") == GlobalValues.V2G_SECURITY_WITH_TLS.get_byte_value().decode("utf8"):
            sec = "TLS"

        else:
            sec = "TCP"

        logging.info("Security level " + sec + " was chosen")

    def set_session_retry_counter(self, session_retry_counter: int) -> None:
        """
        Sets the session retry counter
        :param session_retry_counter: int
        :return: None
        """
        self._session_retry_counter = session_retry_counter

    def set_transport_layer_client(self, transport_layer_client: StatefulTransportLayerClient) -> None:
        """
        Sets the transport layer client
        :param transport_layer_client: StatefulTransportLayerClient
        :return: None
        """
        self._transport_layer_client = transport_layer_client

    def set_transport_layer_thread(self, transport_layer_thread) -> None:
        """
        Sets the transport layer thread
        :param transport_layer_thread:
        :return: None
        """
        self._transport_layer_thread = transport_layer_thread

    def set_v2g_communication_session_evcc(self, v2g_communication_session_evcc) -> None:
        """
        Sets the evcc-sided communication session
        :param v2g_communication_session_evcc: V2GCommunicationSessionEVCC
        :return: None
        """
        self._v2g_communication_session_evcc = v2g_communication_session_evcc

    def set_v2g_tp_message(self, v2g_tp_message: V2GTPMessage) -> None:
        """
        Sets the V2G-TransportProtocol-Message
        :param v2g_tp_message: V2GTPMessage
        :return: None
        """
        self._v2g_tp_message = v2g_tp_message

    def __start_new_session(self, secc_discovery_res: SECCDiscoveryRes) -> bool:
        """
        Sets request counter back to 0, get IP and port of address and logs it. Also activates TLS if agreed on and
        initiates sending of next message (SupportedAppProtocolReq)
        :param secc_discovery_res: SECCDiscoveryRes
        :return: bool that is true if everything worked and sending of SupportedAppProtocolReq was initiated, false
        otherwise
        """
        if secc_discovery_res is not None:
            self.set_secc_discovery_request_counter(0)

            try:
                # TODO: not 100% sure if ipaddress.ip_address works here like this
                secc_address = ipaddress.ip_address(secc_discovery_res.get_secc_ip_address())

            except socket.herror as e:
                logging.fatal("SECC address could not be resolved", e)
                return False

            # TODO: not 100% sure if ipaddress.ip_address works here
            logging.info("UDP server responded: SECC reachable at address " + str(ipaddress.ip_address(secc_address)) +
                         " and port " + str(int.from_bytes(secc_discovery_res.get_secc_port(), byteorder='big')))

            if not self.__start_transport_layer_client(secc_discovery_res, secc_address):
                return False

            self.set_v2g_communication_session_evcc(V2GCommunicationSessionEVCC(self.get_transport_layer_client()))

            self.get_transport_layer_client().register(self.get_v2g_communication_session_evcc())
            self.get_v2g_communication_session_evcc().register(self)

            if self.get_security().decode("utf8") == GlobalValues.V2G_SECURITY_WITH_TLS.get_byte_value().decode("utf8"):
                secure_conn = True

            else:
                secure_conn = False

            self.get_v2g_communication_session_evcc().set_tls_connection(secure_conn)

            self.__send_supported_app_protocol_req()

        else:
            logging.fatal("Maximum number of SECCDiscoveryReq messages reached")
            return False

        return True

    def __start_transport_layer_client(self, secc_discovery_res: SECCDiscoveryRes, secc_address) -> bool:
        """
        Checks if TLS or TCP and initiates instance of respective client. Also starts a transport layer thread
        :param secc_discovery_res: SECCDiscoveryRes
        :param secc_address:
        :return: bool that is true if everything worked, false otherwise
        """
        if secc_discovery_res.get_security().decode("utf8") == self.get_security().decode("utf8"):
            security_agreement = True

        else:
            security_agreement = False

        if security_agreement and self.is_secure_communication():
            if TLSClient.get_instance().initialize(secc_address, int.from_bytes(secc_discovery_res.get_secc_port(),
                                                                                byteorder='big')):
                self.set_transport_layer_client(TLSClient.get_instance())

            else:
                logging.fatal("TLS client could not be initialized")
                return False

        elif security_agreement and not self.is_secure_communication():
            if TCPClient.get_instance().initialize(secc_address, int.from_bytes(secc_discovery_res.get_secc_port(),
                                                                                byteorder='big')):
                self.set_transport_layer_client(TCPClient.get_instance())

            else:
                logging.fatal("TCP client could not be initialized")
                return False

        else:
            logging.fatal("EVCC and SECC could not agree on security level of transport layer")
            return False

        self.set_transport_layer_thread(Thread(target=self.get_transport_layer_client()))
        self.get_transport_layer_thread().start()

        return True

    def __terminate(self, termination_object: TerminateSession) -> None:
        """
        Sets interrupt-parameter of the Thread to True and stops the instance of the UDPClient
        :param termination_object: TerminateSession
        :return: None
        """
        self.get_transport_layer_thread()._interrupt = True
        self.set_v2g_communication_session_evcc(None)
        UDPClient.get_instance().stop()

        if not termination_object.is_successful_termination():
            pass

    def update(self, obs, obj) -> None:
        """
        Checks if obs is of type V2GCommunicationSessionEVCC and if so pauses or terminates the session. If obs is of
        type TCPClient ir TLSClient, obj is terminated
        :param obs:
        :param obj:
        :return: None
        """
        if isinstance(obs, V2GCommunicationSessionEVCC) and (
                isinstance(obj, PauseSession) or isinstance(obj, TerminateSession)):
            self.get_transport_layer_client().stop()
            self.get_transport_layer_thread()._interrupt = True

            if isinstance(obj, PauseSession):
                # If some action is needed by the sessionHandler when pausing, it can be done here.
                # If TCP / TLS client sends notification, it should always be a TerminateSession instance
                # (because a failure of the connection to the TCP / TLS server is its only reason for notification).
                pass

            elif isinstance(obj, TerminateSession):
                self.__terminate(obj)

        elif isinstance(obs, TCPClient) or isinstance(obs, TLSClient):
            self.__terminate(obj)

        else:
            logging.warning("Notification coming from " + obs.__class__.__name__ + " unknown: " +
                            obj.__class__.__name__)
