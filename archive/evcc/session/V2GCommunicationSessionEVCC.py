#######################################################
#
# V2GCommunicationSessionEVCC.py
# Python implementation of the Class V2GCommunicationSessionEVCC
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:11:09
# Original author: Fabian.Stichtenoth
# 
#######################################################
from typing import List
import time
import logging

from shared.v2gMessages.msgDef.ChargeParameterDiscoveryReqType import ChargeParameterDiscoveryReqType
from shared.v2gMessages.msgDef.ChargingProfileType import ChargingProfileType
from shared.v2gMessages.msgDef.ChargingSessionType import ChargingSessionType
from shared.v2gMessages.appProtocol.AppProtocolType import AppProtocolType
from shared.utils.SecurityUtils import ContractCertificateStatus
from evcc.evController.IEVController import IEVController
from shared.v2gMessages.msgDef.ServiceListType import ServiceListType
from shared.v2gMessages.msgDef.EnergyTransferModeType import EnergyTransferModeType
from shared.v2gMessages.msgDef.SAScheduleListType import SAScheduleListType
from shared.v2gMessages.msgDef.PaymentOptionType import PaymentOptionType
from shared.v2gMessages.msgDef.SelectedServiceListType import SelectedServiceListType
from shared.v2gMessages.msgDef.SAScheduleListType import SAScheduleListType
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.messageHandling.SendMessage import SendMessage
from shared.messageHandling.TerminateSession import TerminateSession
from shared.messageHandling.PauseSession import PauseSession
from shared.messageHandling.ChangeProcessingState import ChangeProcessingState
from shared.messageHandling.MessageHandler import MessageHandler
from shared.misc.V2GCommunicationSession import V2GCommunicationSession
from shared.misc.State import State
from shared.misc.V2GTPMessage import V2GTPMessage
from shared.enumerations.V2GMessages import V2GMessages
from shared.enumerations.CPStates import CPStates
from shared.enumerations.GlobalValues import GlobalValues
from evcc.transportLayer.StatefulTransportLayerClient import StatefulTransportLayerClient
from evcc.states.WaitForSupportedAppProtocolRes import WaitForSupportedAppProtocolRes
from evcc.states.WaitForSessionSetupRes import WaitForSessionSetupRes
from evcc.states.WaitForServiceDiscoveryRes import WaitForServiceDiscoveryRes
from evcc.states.WaitForServiceDetailRes import WaitForServiceDetailRes
from evcc.states.WaitForPaymentServiceSelectionRes import WaitForPaymentServiceSelectionRes
from evcc.states.WaitForCertificateInstallationRes import WaitForCertificateInstallationRes
from evcc.states.WaitForCertificateUpdateRes import WaitForCertificateUpdateRes
from evcc.states.WaitForPaymentDetailsRes import WaitForPaymentDetailsRes
from evcc.states.WaitForAuthorizationRes import WaitForAuthorizationRes
from evcc.states.WaitForChargeParameterDiscoveryRes import WaitForChargeParameterDiscoveryRes
from evcc.states.WaitForCableCheckRes import WaitForCableCheckRes
from evcc.states.WaitForPreChargeRes import WaitForPreChargeRes
from evcc.states.WaitForPowerDeliveryRes import WaitForPowerDeliveryRes
from evcc.states.WaitForChargingStatusRes import WaitForChargingStatusRes
from evcc.states.WaitForCurrentDemandRes import WaitForCurrentDemandRes
from evcc.states.WaitForMeteringReceiptRes import WaitForMeteringReceiptRes
from evcc.states.WaitForWeldingDetectionRes import WaitForWeldingDetectionRes
from evcc.states.WaitForSessionStopRes import WaitForSessionStopRes
from evcc.evController.DummyEVController import DummyEVController
from evcc.transportLayer.TCPClient import TCPClient
from evcc.transportLayer.TLSClient import TLSClient


class V2GCommunicationSessionEVCC(V2GCommunicationSession):
    """The state machine
    """

    def __init__(self, transport_layer_client: StatefulTransportLayerClient):
        self._v2g_evcc_communication_setup_timer = 0
        self._evse_id: str = ""
        self._reaction_to_incoming_message = None
        self._charge_parameter_discovery_req = None
        self._stop_charging_requested: bool = False
        self._renegotiation_requested: bool = False
        self._pausing_v2g_comm_session: bool = False
        self._charging_profile = None
        self._offered_services = None
        self._selected_services = None
        self._service_details_to_be_requested = None
        self._requested_energy_transfer_mode = None
        self._evse_schedule_received = 0
        self._supported_app_protocols = None
        self._chosen_app_protocol = None
        self._old_session_joined: bool = False
        self._ev_controller = None
        self._evse_timestamp = 0
        self._sa_schedules = None
        self._sa_schedules_received = 0
        self._change_to_state = None
        self._transport_layer_client = None
        self._contract_cert_status = None
        self._ongoing_timer = 0
        self._is_ongoing_timer_active: bool = False
        self._sent_gen_challenge: bytes = b''
        self._selected_payment_option = None
        self.subscribers = set()

        self.set_transport_layer_client(transport_layer_client)

        self.get_states()[V2GMessages.SUPPORTED_APP_PROTOCOL_RES] = WaitForSupportedAppProtocolRes(self)
        self.get_states()[V2GMessages.SESSION_SETUP_RES] = WaitForSessionSetupRes(self)
        self.get_states()[V2GMessages.SERVICE_DISCOVERY_RES] = WaitForServiceDiscoveryRes(self)
        self.get_states()[V2GMessages.SERVICE_DETAIL_RES] = WaitForServiceDetailRes(self)
        self.get_states()[V2GMessages.PAYMENT_SERVICE_SELECTION_RES] = WaitForPaymentServiceSelectionRes(self)
        self.get_states()[V2GMessages.CERTIFICATE_INSTALLATION_RES] = WaitForCertificateInstallationRes(self)
        self.get_states()[V2GMessages.CERTIFICATE_UPDATE_RES] = WaitForCertificateUpdateRes(self)
        self.get_states()[V2GMessages.PAYMENT_DETAILS_RES] = WaitForPaymentDetailsRes(self)
        self.get_states()[V2GMessages.AUTHORIZATION_RES] = WaitForAuthorizationRes(self)
        self.get_states()[V2GMessages.CHARGE_PARAMETER_DISCOVERY_RES] = WaitForChargeParameterDiscoveryRes(self)
        self.get_states()[V2GMessages.CABLE_CHECK_RES] = WaitForCableCheckRes(self)
        self.get_states()[V2GMessages.PRE_CHARGE_RES] = WaitForPreChargeRes(self)
        self.get_states()[V2GMessages.POWER_DELIVERY_RES] = WaitForPowerDeliveryRes(self)
        self.get_states()[V2GMessages.CHARGING_STATUS_RES] = WaitForChargingStatusRes(self)
        self.get_states()[V2GMessages.CURRENT_DEMAND_RES] = WaitForCurrentDemandRes(self)
        self.get_states()[V2GMessages.METERING_RECEIPT_RES] = WaitForMeteringReceiptRes(self)
        self.get_states()[V2GMessages.WELDING_DETECTION_RES] = WaitForWeldingDetectionRes(self)
        self.get_states()[V2GMessages.SESSION_STOP_RES] = WaitForSessionStopRes(self)

        self.set_start_state(self.get_states().get(V2GMessages.SUPPORTED_APP_PROTOCOL_RES))
        self.set_current_state(self.get_start_state())

        self.set_ev_controller(DummyEVController(self))

        self.__set_v2g_evcc_communication_setup_timer(time.time_ns())

        self.set_contract_cert_status(ContractCertificateStatus.UNKNOWN)

        logging.debug("\n*******************************************" +
                      "\n* New V2G communication session initialized" +
                      "\n*******************************************")

    def register(self, who):
        """
        Register (addObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.add(who)

    def unregister(self, who):
        """
        Unregister (deleteObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.discard(who)

    def dispatch(self):
        """
        Dispatch method of Observer pattern. Calls update method in the subscriber class and makes reaction possible
        :return: None
        """
        for subscriber in self.subscribers:
            subscriber.update()

    def __delete_session_properties(self) -> None:
        pass

    def get_change_to_state(self) -> CPStates:
        """Returns the current CP State
        :return _change_to_state: CPStates
        """
        return self._change_to_state

    def get_charge_parameter_discovery_req(self) -> ChargeParameterDiscoveryReqType:
        """Returns the message ChargeParameterDiscoveryReq
        :return _charge_parameter_discovery_req: ChargeParameterDiscoveryReqType
        """
        return self._charge_parameter_discovery_req

    def get_charging_profile(self) -> ChargingProfileType:
        """
        Returns the charging profile
        :return _charging_profile: ChargingProfileType
        """
        return self._charging_profile

    def get_chosen_app_protocol(self) -> AppProtocolType:
        """
        Returns the by the evcc chosen app protocols
        :return _chosen_app_protocol: AppProtocolType
        """
        return self._chosen_app_protocol

    def get_contract_cert_status(self) -> ContractCertificateStatus:
        """
        Returns the Contract Certificate Status
        :return _contract_cert_status: ContractCertificateStatus
        """
        return self._contract_cert_status

    def get_ev_controller(self) -> IEVController:
        """
        Returns the ev controller which currently is replaced by a dummy
        :return _ev_controller: IEVController
        """
        return self._ev_controller

    def get_evse_id(self) -> str:
        """
        Returns the evse id
        :return _evse_id: str
        """
        return self._evse_id

    def get_evse_schedule_received(self):
        """
        Returns a parameter that indicates if the evse schedule was received
        :return _evse_schedule_received:
        """
        return self._evse_schedule_received

    def get_evse_timestamp(self):
        """
        Returns the evse timestamp
        :return _evse_timestamp:
        """
        return self._evse_timestamp

    def get_offered_services(self) -> ServiceListType:
        """
        Check if _offered_services is already set and if not, sets it. Then returns the offered services.
        :return _offered_services: ServiceListType
        """
        if self._offered_services is None:
            self.set_offered_services(ServiceListType())
        return self._offered_services

    def get_ongoing_timer(self):
        """
        Returns the ongoing timer
        :return _ongoing_timer:
        """
        return self._ongoing_timer

    def get_reaction_to_incoming_message(self) -> ReactionToIncomingMessage:
        """
        Returns the defined reaction on how to deal with the incoming message
        :return _reaction_to_incoming_message: ReactionToIncomingMessage
        """
        return self._reaction_to_incoming_message

    def get_requested_energy_transfermode(self) -> EnergyTransferModeType:
        """
        returns the, for the charging session requested, energy transfermode
        :return _requested_energy_transfer_mode: EnergyTransferModeType
        """
        return self._requested_energy_transfer_mode

    def get_sa_schedules(self) -> SAScheduleListType:
        """
        Returns the sa schedules
        :return _sa_schedules: SAScheduleListType
        """
        return self._sa_schedules

    def get_sa_schedules_received(self):
        """
        Returns a parameter that indicates if the sa schedules were received
        :return _sa_schedules_received:
        """
        return self._sa_schedules_received

    def get_selected_payment_option(self) -> PaymentOptionType:
        """
        Returns the selected payment option. Can be contract or external. For PnC, contract is required
        :return _selected_payment_option: PaymentOptionType
        """
        return self._selected_payment_option

    def get_selected_services(self) -> SelectedServiceListType:
        """
        Check if _selected_services is already set and if not, sets it. Then returns the selected services.
        :return _selected_services: SelectedServiceListType
        """
        if self._selected_services is None:
            self.set_selected_services(SelectedServiceListType())
        return self._selected_services

    def get_sent_gen_challenge(self) -> bytes:
        """
        Returns the sent gen challenge
        :return _sent_gen_challenge: bytes
        """
        return self._sent_gen_challenge

    def get_service_details_to_be_requested(self):
        """
        Check if _service_details_to_be_requested is already set and if not, sets it. Then returns the service details
        which are requested.
        :return _service_details_to_be_requested:
        """
        if self._service_details_to_be_requested is None:
            self._service_details_to_be_requested = []
        return self._service_details_to_be_requested

    def get_supported_app_protocols(self) -> List[AppProtocolType]:
        """
        Returns the by the evcc supported app protocols
        :return _supported_app_protocols: List[AppProtocolType]
        """
        return self._supported_app_protocols

    def get_transport_layer_client(self) -> StatefulTransportLayerClient:
        """
        Returns the transport layer client
        :return _transport_layer_client: StatefulTransportLayerClient
        """
        return self._transport_layer_client

    def get_v2g_evcc_communication_setup_timer(self):
        """
        Returns the communication setup timer
        :return _v2g_evcc_communication_setup_timer:
        """
        return self._v2g_evcc_communication_setup_timer

    def is_certificate_service_available(self, parameter_set_id) -> bool:
        """Checks if the respective service for installing or updating a certificate is
        offered by the SECC and has been selected by the EVCC.
        :param parameter_set_id: 1 for installing a certificate, 2 for updating a certificate
        :return bool: True, if the respective certificate service is available, false
        otherwise
        """
        for service in self.get_selected_services().get_selected_service():
            if service.get_service_id() == 2 \
                    and service.get_parameter_set_id() is not None \
                    and service.get_parameter_set_id() == parameter_set_id:
                return True

        return False

    def is_old_session_joined(self) -> bool:
        """
        Returns a parameter that indicates if an old session was joined
        :return _old_session_joined: bool
        """
        return self._old_session_joined

    def is_ongoing_timer_active(self) -> bool:
        """
        Returns a parameter that indicates if the ongoing timer is still active
        :return _is_ongoing_timer_active: bool
        """
        return self._is_ongoing_timer_active

    def is_pausing_v2g_comm_session(self) -> bool:
        """
        Returns a parameter that indicates if a session was paused
        :return _pausing_v2g_comm_session: bool
        """
        return self._pausing_v2g_comm_session

    def is_renegotiation_requested(self) -> bool:
        """
        Returns a parameter that indicates if a renegotiation was requested
        :return _renegotiation_requested: bool
        """
        return self._renegotiation_requested

    def is_stop_charging_requested(self) -> bool:
        """
        Returns a parameter that indicates if a charging stop was requested
        :return _stop_charging_requested: bool
        """
        return self._stop_charging_requested

    def __process_reaction(self, reaction_to_incoming_message: ReactionToIncomingMessage) -> None:
        """
        Checks how it should be reacted to a received message. Options are pausing, terminating, changing the processing
        state, sending a new message or an error message that also terminates the session
        :param reaction_to_incoming_message: ReactionToIncomingMessage
        :return : None
        """
        if isinstance(reaction_to_incoming_message, SendMessage):
            self.send(reaction_to_incoming_message)

        elif isinstance(reaction_to_incoming_message, TerminateSession):
            self.__delete_session_properties()
            self.terminate_session(reaction_to_incoming_message)

        elif isinstance(reaction_to_incoming_message, PauseSession):
            self.__save_session_properties()
            self.pause_session(reaction_to_incoming_message)

        elif isinstance(reaction_to_incoming_message, ChangeProcessingState):
            self.set_current_state(reaction_to_incoming_message).get_new_state()
            self.__process_reaction(self.get_current_state().process_incoming_message(reaction_to_incoming_message))

        else:
            self.terminate_session("Reaction to incoming message is undefined", False)

    def __save_session_properties(self) -> None:
        pass

    def send(self, sending_params: SendMessage) -> None:
        """
        Method gets called by __process_reaction and prepares the sending of the next message. Also changes the cp state
        if needed and terminates the session if something goes wrong
        :param sending_params: SendMessage
        :return : None
        """
        self.set_v2g_tp_message(
            V2GTPMessage(GlobalValues.V2GTP_VERSION_1_IS.get_byte_value(),
                         GlobalValues.V2GTP_PAYLOAD_TYPE_EXI_ENCODED_V2G_MESSAGE.get_byte_array_value(),
                         self.get_message_handler().v2g_msg_to_exi(sending_params.get_payload())))

        self.get_transport_layer_client().send(self.get_v2g_tp_message(), sending_params.get_timeout())

        if self.get_change_to_state() is not None:
            if self.get_ev_controller().set_cp_state(self.get_change_to_state()):
                self.set_change_to_state(None)

            else:
                self.terminate_session("State change to " + str(self.get_change_to_state()) + " not successful", False)

        if sending_params.get_next_state() is not None:
            self.set_current_state(sending_params.get_next_state())

        else:
            self.terminate_session("State machine interrupted, no new state provided", True)

    def set_change_to_state(self, change_to_state) -> None:
        """
        Sets the CP state
        :param change_to_state: CPStates
        :return: None
        """
        self._change_to_state = change_to_state

    def set_charge_parameter_discovery_req(
            self, charge_parameter_discovery_req: ChargeParameterDiscoveryReqType) -> None:
        """
        Sets the received ChargeParameterDiscoveryReq
        :param charge_parameter_discovery_req: ChargeParameterDiscoveryReqType
        :return: None
        """
        self._charge_parameter_discovery_req = charge_parameter_discovery_req

    def set_charging_profile(self, charging_profile: ChargingProfileType) -> None:
        """
        Sets the charging profile
        :param charging_profile: ChargingProfileType
        :return: None
        """
        self._charging_profile = charging_profile

    def set_chosen_app_protocol(self, chosen_app_protocol: AppProtocolType) -> None:
        """
        Sets the chosen app protocol
        :param chosen_app_protocol: AppProtocolType
        :return: None
        """
        self._chosen_app_protocol = chosen_app_protocol

    def set_contract_cert_status(self, contract_cert_status: ContractCertificateStatus) -> None:
        """
        Sets the contract certificate status
        :param contract_cert_status: ContractCertificateStatus
        :return: None
        """
        self._contract_cert_status = contract_cert_status

    def set_ev_controller(self, ev_controller: IEVController) -> None:
        """
        Sets the EV controller. The EV controller is currently represented by a dummy
        :param ev_controller: IEVController
        :return: None
        """
        self._ev_controller = ev_controller

    def set_evse_id(self, evse_id: str) -> None:
        """
        Sets the evse id
        :param evse_id: str
        :return: None
        """
        self._evse_id = evse_id

    def set_evse_schedule_received(self, evse_schedule_received) -> None:
        """
        Sets the received evse schedule
        :param evse_schedule_received:
        :return: None
        """
        self._evse_schedule_received = evse_schedule_received

    def set_evse_timestamp(self, evse_time_stamp) -> None:
        """
        Sets the evse timestamp
        :param evse_time_stamp:
        :return: None
        """
        self._evse_timestamp = evse_time_stamp

    def set_offered_services(self, offered_services: ServiceListType) -> None:
        """
        Sets the offered services
        :param offered_services: ServiceListType
        :return: None
        """
        self._offered_services = offered_services

    def set_old_session_joined(self, old_session_joined: bool) -> None:
        """
        Sets a parameter that indicates if an old session was joined
        :param old_session_joined: bool
        :return: None
        """
        self._old_session_joined = old_session_joined

    def set_ongoing_timer(self, ongoing_timer) -> None:
        """
        Sets the ongoing timer
        :param ongoing_timer:
        :return: None
        """
        self._ongoing_timer = ongoing_timer

    def set_ongoing_timer_active(self, is_ongoing_timer_active: bool) -> None:
        """
        Sets a parameter that indicates if the ongoing timer is active
        :param is_ongoing_timer_active: bool
        :return: None
        """
        self._is_ongoing_timer_active = is_ongoing_timer_active

    def set_pausing_v2g_comm_session(self, pausing_v2g_comm_session: bool) -> None:
        """
        Sets a parameter that indicates if the V2GCommSession should be paused
        :param pausing_v2g_comm_session: bool
        :return: None
        """
        self._pausing_v2g_comm_session = pausing_v2g_comm_session

    def set_reaction_to_incoming_message(self, reaction_to_incoming_message: ReactionToIncomingMessage) -> None:
        """
        Sets the defined reaction on how to deal with the incoming message
        :param reaction_to_incoming_message: ReactionToIncomingMessage
        :return: None
        """
        self._reaction_to_incoming_message = reaction_to_incoming_message

    def set_renegotiation_requested(self, renegotiation_requested: bool) -> None:
        """
        Sets a parameter that indicates if a renegotiation was requested
        :param renegotiation_requested: bool
        :return: None
        """
        self._renegotiation_requested = renegotiation_requested

    def set_requested_energy_transfermode(self, requested_energy_transfer_mode: EnergyTransferModeType) -> None:
        """
        Sets the requested energy transfermode (AC, DC)
        :param requested_energy_transfer_mode: EnergyTransferModeType
        :return: None
        """
        self._requested_energy_transfer_mode = requested_energy_transfer_mode

    def set_sa_schedules(self, sa_schedules: SAScheduleListType) -> None:
        """
        Sets the sa schedules and the time when they were received
        :param sa_schedules: SAScheduleListType
        :return: None
        """
        self._sa_schedules = sa_schedules
        self._sa_schedules_received = time.time_ns()

    def set_selected_payment_option(self, selected_payment_option: PaymentOptionType) -> None:
        """
        Sets the selected payment option (contract, external)
        :param selected_payment_option: PaymentOptionType
        :return: None
        """
        self._selected_payment_option = selected_payment_option

    def set_selected_services(self, selected_services: SelectedServiceListType) -> None:
        """
        Sets the selected services
        :param selected_services: SelectedServiceListType
        :return: None
        """
        self._selected_services = selected_services

    def set_sent_gen_challenge(self, sent_gen_challenge: bytes) -> None:
        """
        Sets the sent gen challenge
        :param sent_gen_challenge: bytes
        :return: None
        """
        self._sent_gen_challenge = sent_gen_challenge

    def set_service_details_to_be_requested(self, service_details_to_be_requested) -> None:
        """
        Sets the service details which should get requested
        :param service_details_to_be_requested:
        :return: None
        """
        self._service_details_to_be_requested = service_details_to_be_requested

    def set_stop_charging_requested(self, stop_charging_requested: bool):
        """
        Sets a parameter that indicates if a charging stop was requested
        :param stop_charging_requested: bool
        :return: None
        """
        self._stop_charging_requested = stop_charging_requested

    def set_supported_app_protocols(self, supported_app_protocols) -> None:
        """
        Sets the supported app protocols
        :param supported_app_protocols:
        :return: None
        """
        self._supported_app_protocols = supported_app_protocols

    def set_transport_layer_client(self, transport_layer_client: StatefulTransportLayerClient) -> None:
        """
        Sets the transport layer client
        :param transport_layer_client: StatefulTransportLayerClient
        :return: None
        """
        self._transport_layer_client = transport_layer_client

    def __set_v2g_evcc_communication_setup_timer(self, v2g_evcc_communication_setup_timer) -> None:
        """
        Sets the communication setup timer
        :param v2g_evcc_communication_setup_timer:
        :return: None
        """
        self._v2g_evcc_communication_setup_timer = v2g_evcc_communication_setup_timer

    def update(self, obs, obj) -> None:
        """
        Checks if TLS or TCP Message was received and if it is valid. If so, extracts relevant part of the message and
        starts __process_reaction. If something goes wrong, session is terminated
        :param obs: instance of TCP or TLSClient
        :param obj: received message
        :return: None
        """
        if (isinstance(obs, TCPClient) or isinstance(obs, TLSClient)) and isinstance(obj, bytes):
            self.set_v2g_tp_message(V2GTPMessage(obj))

            if self.get_message_handler().is_v2g_tp_message_valid(self.get_v2g_tp_message()):

                if self.get_current_state() == self.get_states().get(V2GMessages.SUPPORTED_APP_PROTOCOL_RES):
                    obj = self.get_message_handler().exi_to_supp_app_protocol_msg(
                        self.get_v2g_tp_message().get_payload())

                else:
                    try:
                        obj = self.get_message_handler().exi_to_v2g_msg(self.get_v2g_tp_message().get_payload())

                    except TypeError as e:
                        self.terminate_session("Received incoming message is not a valid V2GTPMessage\n" + str(e),
                                               False)

                self.__process_reaction(self.get_current_state().process_incoming_message(obj))

            else:
                self.terminate_session("Received incoming message is not a valid V2GTPMessage", False)

        elif (isinstance(obs, TCPClient) or isinstance(obs, TLSClient)) and obj is None:
            self.terminate_session("Transport layer has notified an error", False)

        else:
            self.terminate_session("Notification received, but sending entity or received object not identifiable",
                                   False)
