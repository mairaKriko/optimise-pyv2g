#######################################################
# 
# ClientState.py
# Python implementation of the Class ClientState
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:12:31
# Original author: Fabian.Stichtenoth
# 
#######################################################
import numpy as np
import logging
from lxml import etree

from evcc.session.V2GCommunicationSessionEVCC import V2GCommunicationSessionEVCC
from evcc.evController.DummyEVController import DummyEVController
from evcc.evController.IDCEVController import IDCEVController
from shared.v2gMessages.msgDef.AuthorizationReqType import AuthorizationReqType
from shared.v2gMessages.msgDef.CableCheckReqType import CableCheckReqType
from shared.v2gMessages.msgDef.ChargeParameterDiscoveryReqType import ChargeParameterDiscoveryReqType
from shared.v2gMessages.msgDef.CurrentDemandReqType import CurrentDemandReqType
from shared.v2gMessages.msgDef.PaymentDetailsReqType import PaymentDetailsReqType
from shared.v2gMessages.msgDef.PaymentServiceSelectionReqType import PaymentServiceSelectionReqType
from shared.v2gMessages.msgDef.PowerDeliveryReqType import PowerDeliveryReqType
from shared.v2gMessages.msgDef.ServiceDetailReqType import ServiceDetailReqType
from shared.v2gMessages.msgDef.SessionStopReqType import SessionStopReqType
from shared.v2gMessages.msgDef.MessageHeaderType import MessageHeaderType
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from shared.v2gMessages.msgDef.EnergyTransferModeType import EnergyTransferModeType
from shared.v2gMessages.msgDef.ChargeProgressType import ChargeProgressType
from shared.v2gMessages.msgDef.ChargingSessionType import ChargingSessionType
from shared.v2gMessages.msgDef.ResponseCodeType import ResponseCodeType
from shared.v2gMessages.msgDef.SessionSetupResType import SessionSetupResType
from shared.v2gMessages.msgDef.ServiceDiscoveryResType import ServiceDiscoveryResType
from shared.v2gMessages.msgDef.ServiceDetailResType import ServiceDetailResType
from shared.v2gMessages.msgDef.PaymentServiceSelectionResType import PaymentServiceSelectionResType
from shared.v2gMessages.msgDef.PaymentDetailsResType import PaymentDetailsResType
from shared.v2gMessages.msgDef.CertificateInstallationResType import CertificateInstallationResType
from shared.v2gMessages.msgDef.CertificateUpdateResType import CertificateUpdateResType
from shared.v2gMessages.msgDef.AuthorizationResType import AuthorizationResType
from shared.v2gMessages.msgDef.ChargeParameterDiscoveryResType import ChargeParameterDiscoveryResType
from shared.v2gMessages.msgDef.CableCheckResType import CableCheckResType
from shared.v2gMessages.msgDef.PreChargeResType import PreChargeResType
from shared.v2gMessages.msgDef.PowerDeliveryResType import PowerDeliveryResType
from shared.v2gMessages.msgDef.ChargingStatusResType import ChargingStatusResType
from shared.v2gMessages.msgDef.CurrentDemandResType import CurrentDemandResType
from shared.v2gMessages.msgDef.MeteringReceiptResType import MeteringReceiptResType
from shared.v2gMessages.msgDef.WeldingDetectionResType import WeldingDetectionResType
from shared.v2gMessages.msgDef.SessionStopResType import SessionStopResType
from shared.misc.State import State
from shared.utils.SecurityUtils import SecurityUtils
from shared.utils.MiscUtils import MiscUtils
from shared.enumerations.GlobalValues import GlobalValues
from shared.enumerations.CPStates import CPStates
from shared.enumerations.V2GMessages import V2GMessages


class ClientState(State):
    """Some request messages are to be sent from different states which makes it more
    convenient (having less code and being less error-prone) to keep the creation
    of those messages in one single class.
    """

    def __init__(self, comm_session_context: V2GCommunicationSessionEVCC):
        super().__init__(comm_session_context)

    @staticmethod
    def _get_authorization_req(gen_challenge) -> AuthorizationReqType:
        """An AuthorizationReq needs to be generated from several states:
        - WaitForPaymentServiceSelectionRes (no genChallenge)
        - WaitForPaymentDetailsRes (genChallenge)
        - WaitForAuthorizationRes (no genChallenge, EVSE is still processing)
        This method generates the AuthorizationReq
        :param gen_challenge: bytes
        :return authorization_req: AuthorizationReqType; An AuthorizationReq, either empty or with a set genChallenge
        and ID depending on input parameter
        """
        authorization_req = AuthorizationReqType()

        if gen_challenge is not None:
            authorization_req.set_gen_challenge(gen_challenge)
            authorization_req.set_id("ID1")

        return authorization_req

    def get_cable_check_req(self) -> CableCheckReqType:
        """A CableCheckReq needs to be generated from several states:
        - WaitForChargeParameterDiscoveryRes
        - WaitForCableCheckRes (EVSEProcessing = ONGOING)
        This method generates the CableCheckReq
        :return cable_check_req: CableCheckReqType; A CableCheckReq
        """
        cable_check_req = CableCheckReqType()
        cable_check_req.set_dc_ev_status(self.get_comm_session_context().get_ev_controller().get_dc_ev_status())

        return cable_check_req

    def get_charge_parameter_discovery_req(self) -> ChargeParameterDiscoveryReqType:
        """A ChargeParameterDiscoveryReq needs to be generated from several states:
        - WaitForAuthorizationRes (the initial ChargeParameterDiscoveryReq)
        - WaitForPowerDeliveryRes (in case AC_EVSEStatus requests a renegotiation)
        - WaitForChargingStatusRes (in case AC_EVSEStatus requests a renegotiation)
        This method generates the ChargeParameterDiscoveryReq dependent on the transfermode
        :return charge_parameter_discovery_req: ChargeParameterDiscoveryReqType; A ChargeParameterDiscoveryReq which
        itself consists of several complex datatypes.
        """
        charge_parameter_discovery_req = ChargeParameterDiscoveryReqType()

        charge_parameter_discovery_req.set_requested_energy_transfer_mode(self.get_requested_energy_transfer_mode())

        if str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("AC"):
            charge_parameter_discovery_req.set_ev_charge_parameter(
                self.get_comm_session_context().get_ev_controller().get_ac_ev_charge_parameter())

        else:
            charge_parameter_discovery_req.set_ev_charge_parameter(
                self.get_comm_session_context().get_ev_controller().get_dc_ev_charge_paramter())

        return charge_parameter_discovery_req

    def get_comm_session_context(self) -> V2GCommunicationSessionEVCC:
        return super().get_comm_session_context()

    def get_current_demand_req(self) -> CurrentDemandReqType:
        """A CurrentDemandReq needs to be generated from several states:
        - WaitForCurrentDemandRes (the initial CurrentDemandReq message)
        - WaitForMeteringReceiptRes
        This method generates the CurrentDemandReq
        :return current_demand_req: CurrentDemandReqType; A CurrentDemandReq message
        """
        ev_controller: IDCEVController = self.get_comm_session_context().get_ev_controller()

        current_demand_req = CurrentDemandReqType()
        current_demand_req.set_bulk_charging_complete(ev_controller.is_bulk_charging_complete())
        current_demand_req.set_charging_complete(ev_controller.is_charging_complete())
        current_demand_req.set_dc_ev_status(ev_controller.get_dc_ev_status())
        current_demand_req.set_ev_maximum_current_limit(ev_controller.get_maximum_current_limit())
        current_demand_req.set_ev_maximum_power_limit(ev_controller.get_maximum_power_limit())
        current_demand_req.set_ev_maximum_voltage_limit(ev_controller.get_maximum_voltage_limit())
        current_demand_req.set_ev_target_current(ev_controller.get_target_current())
        current_demand_req.set_ev_target_voltage(ev_controller.get_target_voltage())
        current_demand_req.set_remaining_time_to_bulk_soc(ev_controller.get_remaining_time_to_bulk_soc())
        current_demand_req.set_remaining_time_to_full_soc(ev_controller.get_remaining_time_to_full_soc())

        return current_demand_req

    @staticmethod
    def _get_payment_details_req() -> PaymentDetailsReqType:
        """A PaymentDetailsReq needs to be generated from several states:
        - WaitForPaymentServiceSelectionRes
        - WaitForCertificateInstallationRes
        - WaitForCertificateUpdateRes
        This methode creates the PaymentDetailsReq and checks if the emaid needs to be set
        :return payment_details_req: PaymentDetailsReqType; A PaymentDetailsReq
        """
        evcc_key_store = SecurityUtils.get_keystore(str(GlobalValues.EVCC_KEYSTORE_FILEPATH),
                                                    str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS))
        payment_details_req = PaymentDetailsReqType()

        emaid = SecurityUtils.get_emaid(str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS))

        if emaid is not None:
            payment_details_req.set_emaid(
                SecurityUtils.get_emaid(str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS)).get_value())
            payment_details_req.set_contract_signature_cert_chain(
                SecurityUtils.get_certificate_chain(evcc_key_store, str(GlobalValues.ALIAS_CONTRACT_CERTIFICATE)))

        return payment_details_req

    def get_payment_service_selection_req(self) -> PaymentServiceSelectionReqType:
        """A PaymentServiceSelectionReq needs to be generated from several states:
        - WaitForServiceDiscoveryRes
        - WaitForServiceDetailRes
        This method creates the PaymentServiceSelectionReq
        :return payment_service_selection_req: PaymentServiceSelectionReqType; A PaymentServiceSelectionReq
        """
        payment_service_selection_req = PaymentServiceSelectionReqType()
        payment_service_selection_req.set_selected_payment_option(
            self.get_comm_session_context().get_selected_payment_option())
        payment_service_selection_req.set_selected_service_list(self.get_comm_session_context().get_selected_services)

        return payment_service_selection_req

    def get_power_delivery_req(self, charge_progress: ChargeProgressType) -> PowerDeliveryReqType:
        """A PowerDeliveryReq needs to be generated from several states:
        - WaitForChargeParameterDiscoveryRes
        - WaitForChargingStatusRes
        - WaitForMeteringReceiptRes
        This method creates the PowerDeliveryReq dependent on whether the charge progress is START or STOP and the
        transfermode is AC or DC
        :return power_delivery_req: PowerDeliveryReqType; A ChargeParameterDiscoveryReq which itself consists of several
        complex datatypes.
        """
        power_delivery_req = PowerDeliveryReqType()

        if charge_progress == ChargeProgressType.START:
            if str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("AC"):
                self.get_comm_session_context().set_change_to_state(CPStates.STATE_C)

            charging_profile = self.get_comm_session_context().get_ev_controller().get_charging_profile()
            power_delivery_req.set_charging_profile(charging_profile)

            self.get_comm_session_context().set_charging_profile(charging_profile)

        elif charge_progress == ChargeProgressType.STOP:
            if str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("AC"):
                self.get_comm_session_context().set_change_to_state(CPStates.STATE_B)

        power_delivery_req.set_charge_progress(charge_progress)
        power_delivery_req.set_sa_schedule_tuple_id(
            self.get_comm_session_context().get_ev_controller().get_chosen_sa_schedule_tuple_id())

        if str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("DC"):
            # TODO: JAXBElement needs to be changed

            xml_cont: dict = vars(self.get_comm_session_context().get_ev_controller().get_ev_power_delivery_parameter())

            jaxb_dc_ev_power_delivery_parameter = etree.Element(str("urn_iso_15118_2_2013_MsgDataTypes"))

            for k, v in xml_cont.items():
                element = etree.SubElement(jaxb_dc_ev_power_delivery_parameter, 'AC_EVSEChargeParameter')
                element.set(str(k), v)
            power_delivery_req.set_ev_power_delivery_parameter(jaxb_dc_ev_power_delivery_parameter)

        return power_delivery_req

    def get_requested_energy_transfer_mode(self) -> EnergyTransferModeType:
        """
        Returns the requested energy transfermode. If it is None, the requested energy mode is set
        :return requested_energy_transfer_mode: EnergyTransferModeType
        """
        requested_energy_transfer_mode = MiscUtils.get_property_value("energy.transfermode.requested")

        if requested_energy_transfer_mode is None:
            requested_energy_transfer_mode = \
                self.get_comm_session_context().get_ev_controller().get_requested_energy_transfer_mode()
            self.get_comm_session_context().set_requested_energy_transfermode(requested_energy_transfer_mode)

        return requested_energy_transfer_mode

    def get_service_detail_req(self):
        """A ServiceDetailReq needs to be generated from several states:
        - WaitForServiceDiscoveryRes
        - WaitForServiceDetailRes
        Checks if the list of value added services (VAS) which are to be used contains service IDs. Those
        service IDs can be used in a ServiceDetailReq to request more details about the
        service. Each time a ServiceDetailReq is created, the respective service ID is
        deleted from the list.
        :return service_detail_req: ServiceDetailReqType; A ServiceDetailReq with a service ID whose details are
        requested, if the list of service IDs is not empty. None otherwise.
        """
        if len(self.get_comm_session_context().get_service_details_to_be_requested()) > 0:
            list_iterator = iter(self.get_comm_session_context().get_service_details_to_be_requested())

            service_detail_req = ServiceDetailReqType()
            service_detail_req.set_service_id(next(list_iterator))

            return service_detail_req

        return None

    @staticmethod
    def get_session_stop_req(charging_session_type: ChargingSessionType) -> SessionStopReqType:
        """A SessionStopReq needs to be generated from several states:
        - WaitForPowerDeliveryRes
        - WaitForWeldingDetectionRes
        This method creates the SessionStopReq
        :return session_stop_req: SessionStopReqType; A SessionStopReq message
        """
        session_stop_req = SessionStopReqType()
        session_stop_req.set_charging_session(charging_session_type)

        return session_stop_req

    def __is_header_ok(self, header: MessageHeaderType) -> bool:
        """Performs the following checks:
        - is the returned session ID the same as the one saved by the EVCC?
        - does the EVCC need to react to a possibly set notification?
        - does the EVCC need to check the signature?
        :param header: MessageHeaderType
        :return: bool that is True if header is ok, False otherwise
        """
        if not self == self.get_comm_session_context().get_states().get(
                V2GMessages.SESSION_SETUP_RES) and not np.array_equal(header.get_session_id(),
                                                                      self.get_comm_session_context().get_session_id()):
            logging.error("Session ID is invalid: expected " + str(int.from_bytes(
                self.get_comm_session_context().get_session_id(), byteorder='big')) +
                          ", received " + str(int.from_bytes(header.get_session_id(), byteorder='big')))
            return False

        if header.get_notification() is not None:
            pass

        return True

    def is_incoming_message_valid(self, incoming_message, expected_message) -> bool:
        """
        Checks if incoming_message is of valid type and if expected_message is of right type. Also checks if header and
        response code of incoming_message is valid
        :param incoming_message:
        :param expected_message:
        :return: bool that is True if all checks were positive, False otherwise
        """
        if isinstance(incoming_message, V2GMessage):
            v2g_message = incoming_message

            if not isinstance(expected_message, v2g_message.get_body().get_body_element().get_value.__class__):
                logging.fatal(
                    "Invalid message (" + v2g_message.get_body().get_body_element().get_value().__class__.__name__ +
                    ") at this state (" + self.__class__.__name__ + ")")

                return False

            else:
                logging.debug(
                    v2g_message.get_body().get_body_element().get_value().__class__.__name__.replace("Type", "") +
                    " received")

                if not self.__is_header_ok(v2g_message.get_header()):
                    return False

                if not self.__is_response_code_ok(v2g_message):
                    return False

                return True

        else:
            logging.fatal("Incoming message is not a V2GMessage")
            return False

    def default(self):
        """
        Default method of Switcher
        :return: None
        """
        logging.error("Response message could not be identified")
        return False

    @staticmethod
    def one(bbt: SessionSetupResType):
        """
        First method of switcher
        :param bbt: SessionSetupResType
        :return: None
        """
        v2gMessageRCT = bbt.get_response_code()
        return v2gMessageRCT

    @staticmethod
    def two(bbt: ServiceDiscoveryResType):
        """
        Second method of switcher
        :param bbt: ServiceDiscoveryResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def three(bbt: ServiceDetailResType):
        """
        Third method of switcher
        :param bbt: ServiceDetailResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def four(bbt: PaymentServiceSelectionResType):
        """
        Fourth method of switcher
        :param bbt: PaymentServiceSelectionResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def five(bbt: PaymentDetailsResType):
        """
        Fifth method of switcher
        :param bbt: PaymentDetailsResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def six(bbt: CertificateInstallationResType):
        """
        Sixth method of switcher
        :param bbt: CertificateInstallationResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def seven(bbt: CertificateUpdateResType):
        """
        Seventh method of switcher
        :param bbt: CertificateUpdateResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def eight(bbt: AuthorizationResType):
        """
        Eighth method of switcher
        :param bbt: AuthorizationResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def nine(bbt: ChargeParameterDiscoveryResType):
        """
        Ninth method of switcher
        :param bbt: ChargeParameterDiscoveryResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def ten(bbt: CableCheckResType):
        """
        Tenth method of switcher
        :param bbt: CableCheckResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def eleven(bbt: PreChargeResType):
        """
        Eleventh method of switcher
        :param bbt: PreChargeResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def twelve(bbt: PowerDeliveryResType):
        """
        Twelfth method of switcher
        :param bbt: PowerDeliveryResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def thirteen(bbt: ChargingStatusResType):
        """
        Thirteenth method of switcher
        :param bbt: ChargingStatusResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def fourteen(bbt: CurrentDemandResType):
        """
        Fourteenth method of switcher
        :param bbt: CurrentDemandResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def fifteen(bbt: MeteringReceiptResType):
        """
        Fifteenth method of switcher
        :param bbt: MeteringReceiptResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def sixteen(bbt: WeldingDetectionResType):
        """
        Sixteenth method of switcher
        :param bbt: WeldingDetectionResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    @staticmethod
    def seventeen(bbt: SessionStopResType):
        """
        Seventeenth method of switcher
        :param bbt: SessionStopResType
        :return: None
        """
        v2g_message_rct = bbt.get_response_code()
        return v2g_message_rct

    def __is_response_code_ok(self, response_message: V2GMessage) -> bool:
        """
        Calls switcher that returns respective response code. Then checks if response code starts with OK
        :param response_message: V2GMessage
        :return: bool that returns True if response code is ok, False otherwise
        """
        bbt = response_message.get_body().get_body_element().get_value()

        switcher = {
            "SessionSetupResType": "one",
            "ServiceDiscoveryResType": "two",
            "ServiceDetailResType": "three",
            "PaymentServiceSelectionResType": "four",
            "PaymentDetailsResType": "five",
            "CertificateInstallationResType": "six",
            "CertificateUpdateResType": "seven",
            "AuthorizationResType": "eight",
            "ChargeParameterDiscoveryResType": "nine",
            "CableCheckResType": "ten",
            "PreChargeResType": "eleven",
            "PowerDeliveryResType": "twelve",
            "ChargingStatusResType": "thirteen",
            "CurrentDemandResType": "fourteen",
            "MeteringReceiptResType": "fifteen",
            "WeldingDetectionResType": "sixteen",
            "SessionStopResType": "seventeen"
        }

        func = switcher.get(bbt.__class__.__name__, lambda: self.default())
        v2g_message_rct = func(response_message, bbt)

        if str(v2g_message_rct).startswith("OK"):
            return True

        else:
            logging.error("Negative response code " + str(v2g_message_rct))
            return False

    def payment_service_selection_req(self) -> PaymentServiceSelectionReqType:
        """A ServiceDetailReq needs to be generated from several states:
        - WaitForServiceDiscoveryRes
        - WaitForServiceDetailRes
        This method creates the ServiceDetailReq
        :return payment_service_selection_req: PaymentServiceSelectionReqType
        """
        payment_service_selection_req = PaymentServiceSelectionReqType()
        payment_service_selection_req.set_selected_payment_option(
            self.get_comm_session_context().get_selected_payment_option())

        return payment_service_selection_req
