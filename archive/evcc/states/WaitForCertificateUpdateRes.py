#######################################################
# 
# WaitForCertificateUpdateRes.py
# Python implementation of the Class WaitForCertificateUpdateRes
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:14:59
# Original author: Fabian.Stichtenoth
# 
#######################################################
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.messageHandling.TerminateSession import TerminateSession
from shared.v2gMessages.msgDef.SignatureType import SignatureType
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from shared.v2gMessages.msgDef.CertificateUpdateResType import CertificateUpdateResType
from shared.v2gMessages.msgDef.ResponseCodeType import ResponseCodeType
from shared.utils.SecurityUtils import SecurityUtils
from shared.enumerations.GlobalValues import GlobalValues
from shared.enumerations.PKI import PKI
from shared.enumerations.V2GMessages import V2GMessages
from evcc.session.V2GCommunicationSessionEVCC import V2GCommunicationSessionEVCC
from evcc.states.ClientState import ClientState


class WaitForCertificateUpdateRes(ClientState):

    def __init__(self, comm_session_context: V2GCommunicationSessionEVCC):
        super().__init__(comm_session_context)

    def processIncomingMessage(self, message) -> ReactionToIncomingMessage:
        """
        Initiates check if message is valid. If so, checks if signature and Response Code are valid and if so, processes
        message accordingly. Verifies and saves contract certificate chain. If there's an failure, Session is terminated
        :param message:
        :return: ReactionToIncomingMessage
        """
        if self.is_incoming_message_valid(message, CertificateUpdateResType.__class__):
            v2g_message_res: V2GMessage = message
            certificate_update_res: CertificateUpdateResType = v2g_message_res.get_body().get_body_element().get_value()

            if not self.__verify_signature(certificate_update_res, v2g_message_res.get_header().get_signature()):
                return TerminateSession("Signature verification failed")

            cert_chain_response_code: ResponseCodeType = SecurityUtils.verify_certificate_chain(
                certificate_update_res.get_sa_provisioning_certificate_chain(),
                str(GlobalValues.EVCC_TRUSTSTORE_FILEPATH),
                PKI.CPS)
            if not cert_chain_response_code == ResponseCodeType.OK:
                return TerminateSession("Provisioning certificate chain is not valid")

            contract_cert_private_key = SecurityUtils.get_private_key(
                SecurityUtils.get_keystore(str(GlobalValues.EVCC_KEYSTORE_FILEPATH),
                                           str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS)),
                str(GlobalValues.ALIAS_CONTRACT_CERTIFICATE)
            )

            if not SecurityUtils.save_contract_certificate_chain(
                    str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS),
                    certificate_update_res.get_contract_signature_cert_chain(),
                    SecurityUtils.decrypt_contract_cert_private_key(
                        certificate_update_res.get_dh_public_key().get_value(),
                        certificate_update_res.get_contract_signature_encrypted_private_key().get_value(),
                        contract_cert_private_key
                    )):
                return TerminateSession("Contract certificate chain could not be saved")

            return self.get_send_message(self._get_payment_details_req(), V2GMessages.PAYMENT_DETAILS_RES)

        else:
            return TerminateSession("Incoming message raised an error")

    def __verify_signature(self, certificate_update_res: CertificateUpdateResType, signature: SignatureType) -> bool:
        """
        Creates dict verify_xml_sig_ref_elements with relevant signature data and initiates verification of signature.
        :param certificate_update_res: CertificateInstallationResType
        :param signature: SignatureType
        :return: bool that returns True if signature is valid, False otherwise
        """
        verify_xml_sig_ref_elements = {
            certificate_update_res.get_contract_signature_cert_chain().get_id(): SecurityUtils.generate_digest(
                certificate_update_res.get_contract_signature_cert_chain().get_id(),
                self.get_message_handler().get_jaxb_element(
                    certificate_update_res.get_contract_signature_cert_chain())),

            certificate_update_res.get_contract_signature_encrypted_private_key().get_id():
                SecurityUtils.generate_digest(
                certificate_update_res.get_contract_signature_encrypted_private_key().get_id(),
                self.get_message_handler().get_jaxb_element(
                    certificate_update_res.get_contract_signature_encrypted_private_key())),

            certificate_update_res.get_dh_public_key().get_id(): SecurityUtils.generate_digest(
                certificate_update_res.get_dh_public_key().get_id(),
                self.get_message_handler().get_jaxb_element(certificate_update_res.get_dh_public_key())),

            certificate_update_res.get_emaid().get_id(): SecurityUtils.generate_digest(
                certificate_update_res.get_emaid().get_id(),
                self.get_message_handler().get_jaxb_element(certificate_update_res.get_emaid()))}

        if not SecurityUtils.verify_signature(
                signature,
                self.get_message_handler().get_jaxb_element(signature.get_signed_info()),
                verify_xml_sig_ref_elements,
                certificate_update_res.get_sa_provisioning_certificate_chain().get_certificate()):
            return False

        return True
