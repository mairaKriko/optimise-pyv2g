#######################################################
# 
# WaitForPaymentServiceSelectionRes.py
# Python implementation of the Class WaitForPaymentServiceSelectionRes
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:16:28
# Original author: Fabian.Stichtenoth
# 
#######################################################
import logging

from shared.v2gMessages.msgDef.CertificateInstallationReqType import CertificateInstallationReqType
from shared.v2gMessages.msgDef.CertificateUpdateReqType import CertificateUpdateReqType
from shared.v2gMessages.msgDef.PaymentServiceSelectionResType import PaymentServiceSelectionResType
from shared.v2gMessages.msgDef.PaymentOptionType import PaymentOptionType
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.messageHandling.TerminateSession import TerminateSession
from shared.utils.SecurityUtils import SecurityUtils
from shared.utils.SecurityUtils import ContractCertificateStatus
from shared.enumerations.GlobalValues import GlobalValues
from shared.enumerations.V2GMessages import V2GMessages
from evcc.session.V2GCommunicationSessionEVCC import V2GCommunicationSessionEVCC
from evcc.states.ClientState import ClientState


class WaitForPaymentServiceSelectionRes(ClientState):

    def __init__(self, comm_session_context: V2GCommunicationSessionEVCC):
        super().__init__(comm_session_context)

    def __get_certificate_installation_req(self) -> CertificateInstallationReqType:
        """
        Creates cert_installation_req, maps it into a dict, sets the signature private key and returns
        cert_installation_req
        :return cert_installation_req: CertificateInstallationReqType
        """
        evcc_keystore = SecurityUtils.get_keystore(
            str(GlobalValues.EVCC_KEYSTORE_FILEPATH), str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS)
        )

        cert_installation_req = CertificateInstallationReqType()
        cert_installation_req.set_id("ID1")
        cert_installation_req.set_list_of_root_certificate_ids(
            SecurityUtils.get_list_of_root_certificate_ids(str(GlobalValues.EVCC_TRUSTSTORE_FILEPATH),
                                                           str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS)))
        cert_installation_req.set_oem_provisioning_cert(
            SecurityUtils.get_certificate_chain(
                evcc_keystore, str(GlobalValues.ALIAS_OEM_PROV_CERTIFICATE)).get_certificate())

        self.get_xml_signature_ref_elements()[cert_installation_req.get_id()] = SecurityUtils.generate_digest(
            cert_installation_req.get_id(), self.get_message_handler().get_jaxbelement(cert_installation_req))

        self.set_signature_private_key(SecurityUtils.get_private_key(SecurityUtils.get_keystore(
            str(GlobalValues.EVCC_KEYSTORE_FILEPATH), str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS)
        ), str(GlobalValues.ALIAS_OEM_PROV_CERTIFICATE)
        ))

        return cert_installation_req

    def __get_certificate_update_req(self) -> CertificateUpdateReqType:
        """
        Creates certificate_update_req, maps it into a dict, sets the signature private key and returns
        certificate_update_req
        :return certificate_update_req: CertificateUpdateReqType
        """
        certificate_update_req = CertificateUpdateReqType()
        certificate_update_req.set_contract_signature_cert_chain(
            SecurityUtils.get_certificate_chain(SecurityUtils.get_keystore(
                str(GlobalValues.EVCC_KEYSTORE_FILEPATH), str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS)
            ), str(GlobalValues.ALIAS_CONTRACT_CERTIFICATE)
            ))
        certificate_update_req.set_emaid(
            SecurityUtils.get_emaid(str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS)).get_value())
        certificate_update_req.set_id("ID1")
        certificate_update_req.set_list_of_root_certificate_ids(
            SecurityUtils.get_list_of_root_certificate_ids(str(GlobalValues.EVCC_TRUSTSTORE_FILEPATH),
                                                           str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS)))

        self.get_xml_signature_ref_elements()[certificate_update_req.get_id()] = SecurityUtils.generate_digest(
            certificate_update_req.get_id(), self.get_message_handler().get_jaxb_element(certificate_update_req))

        self.set_signature_private_key(SecurityUtils.get_private_key(
            SecurityUtils.get_keystore(
                str(GlobalValues.EVCC_KEYSTORE_FILEPATH), str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS)
            ), str(GlobalValues.ALIAS_CONTRACT_CERTIFICATE)
        ))

        return certificate_update_req

    def process_incoming_message(self, message) -> ReactionToIncomingMessage:
        """
        Initiates check if message is valid. If so, checks if contract certificate status is "CONTRACT", "UPDATE_NEEDED"
        or "INSTALLATION_NEEDED" and processes message accordingly. If there's an failure, session is terminated
        :param message:
        :return: ReactionToIncomingMessage
        """
        if self.is_incoming_message_valid(message, PaymentServiceSelectionResType.__class__):
            if self.get_comm_session_context().get_selected_payment_option() == PaymentOptionType.CONTRACT:
                if self.get_comm_session_context().get_contract_cert_status() == ContractCertificateStatus.UNKNOWN:
                    self.get_comm_session_context().set_contract_cert_status(
                        SecurityUtils.get_contract_certificate_status())

                if self.get_comm_session_context().get_contract_cert_status() == \
                        ContractCertificateStatus.INSTALLATION_NEEDED:
                    if self.get_comm_session_context().is_certificate_service_available(1):
                        logging.info("Trying to install new contract certificate")
                        return self.get_send_message(self.__get_certificate_installation_req(),
                                                     V2GMessages.CERTIFICATE_INSTALLATION_RES)

                    else:
                        return TerminateSession("Certificate installation needed but service is not available")

                if self.get_comm_session_context().get_contract_cert_status() == \
                        ContractCertificateStatus.UPDATE_NEEDED:
                    if self.get_comm_session_context().is_certificate_service_available(2):
                        logging.info("Trying to update contract certificate")
                        return self.get_send_message(self.__get_certificate_installation_req(),
                                                     V2GMessages.CERTIFICATE_UPDATE_RES)

                    else:
                        return TerminateSession("Certificate update needed but service is not available")

                return self.get_send_message(self._get_payment_details_req(), V2GMessages.PAYMENT_DETAILS_RES)

            elif self.get_comm_session_context().get_selected_payment_option() == PaymentOptionType.EXTERNAL_PAYMENT:
                return self.get_send_message(self._get_authorization_req(None), V2GMessages.AUTHORIZATION_RES)

            else:
                return TerminateSession("No valid PaymentOptionType available")

        else:
            return TerminateSession("Incoming message raised an error")
