#######################################################
# 
# WaitForAuthorizationRes.py
# Python implementation of the Class WaitForAuthorizationRes
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:13:11
# Original author: Fabian.Stichtenoth
# 
#######################################################
import logging
import time

from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.messageHandling.TerminateSession import TerminateSession
from shared.misc.State import State
from shared.misc.TimeRestrictions import TimeRestrictions
from shared.enumerations.V2GMessages import V2GMessages
from shared.enumerations.GlobalValues import GlobalValues
from shared.utils.SecurityUtils import SecurityUtils
from shared.v2gMessages.msgDef.AuthorizationResType import AuthorizationResType
from shared.v2gMessages.msgDef.AuthorizationReqType import AuthorizationReqType
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from shared.v2gMessages.msgDef.EVSEProcessingType import EVSEProcessingType
from shared.v2gMessages.msgDef.PaymentOptionType import PaymentOptionType
from evcc.session.V2GCommunicationSessionEVCC import V2GCommunicationSessionEVCC
from evcc.states.ClientState import ClientState


class WaitForAuthorizationRes(ClientState):

    def __init__(self, comm_session_context: V2GCommunicationSessionEVCC):
        super().__init__(comm_session_context)

    def process_incoming_message(self, message) -> ReactionToIncomingMessage:
        """
        Initiates check if message is valid. If so, processes message dependent on the Processing Type. Type can be
        None, FINISHED or ONGOING. If something goes wrong, Session is terminated.
        :param message:
        :return: ReactionToIncomingMessage
        """
        if self.is_incoming_message_valid(message, AuthorizationResType.__class__):
            v2g_message_res: V2GMessage = message
            authorization_res: AuthorizationResType = v2g_message_res.get_body().get_body_element().get_value()

            if authorization_res.get_evse_processing() is None:
                return TerminateSession("EVSEProcessing parameter of AuthorizationRes is null. Parameter is mandatory.")

            if authorization_res.get_evse_processing() == EVSEProcessingType.FINISHED:
                logging.debug("EVSEProcessing was set to FINISHED")

                self.get_comm_session_context().set_ongoing_timer(0)
                self.get_comm_session_context().set_ongoing_timer_active(False)

                charge_parameter_discovery_req = self.get_charge_parameter_discovery_req()

                self.get_comm_session_context().set_charge_parameter_discovery_req(charge_parameter_discovery_req)

                return self.get_send_message(charge_parameter_discovery_req, V2GMessages.CHARGE_PARAMETER_DISCOVERY_RES)

            else:
                logging.debug("EVSEProcessing was set to ONGOING")

                elapsed_time_in_ms = 0

                if self.get_comm_session_context().is_ongoing_timer_active:
                    elapsed_time = time.time_ns() - self.get_comm_session_context().get_ongoing_timer()
                    elapsed_time_in_ms = elapsed_time / 1000000

                    if elapsed_time_in_ms > TimeRestrictions.V2G_EVCC_ONGOING_TIMEOUT:
                        return TerminateSession("Ongoing timer timed out for AuthorizationReq")

                else:
                    self.get_comm_session_context().set_ongoing_timer(time.time_ns())
                    self.get_comm_session_context().set_ongoing_timer_active(True)

                authorization_req: AuthorizationReqType = None

                if self.get_comm_session_context().get_selected_payment_option() == PaymentOptionType.CONTRACT and \
                        self.get_comm_session_context().is_tls_connection():
                    authorization_req = self._get_authorization_req(
                        self.get_comm_session_context().get_sent_gen_challenge())

                    self.get_xml_signature_ref_elements().put(
                        authorization_req.get_id(),
                        SecurityUtils.generate_digest(authorization_req.get_id(),
                                                      self.get_message_handler().get_jaxb_element(authorization_req)))

                    self.set_signature_private_key(
                        SecurityUtils.get_private_key(
                            SecurityUtils.get_keystore(str(GlobalValues.EVCC_KEYSTORE_FILEPATH),
                                                       str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS)),
                            str(GlobalValues.ALIAS_CONTRACT_CERTIFICATE)))

                else:
                    authorization_req = self._get_authorization_req(None)

                return self.get_send_message(authorization_req, V2GMessages.AUTHORIZATION_RES,
                                            min(TimeRestrictions.V2G_EVCC_ONGOING_TIMEOUT - elapsed_time_in_ms,
                                                TimeRestrictions.get_v2g_evcc_msg_timeout(
                                                    V2GMessages.AUTHORIZATION_RES)))

        else:
            return TerminateSession("Incoming message raised an error")
