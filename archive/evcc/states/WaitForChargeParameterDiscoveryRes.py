#######################################################
# 
# WaitForChargeParameterDiscoveryRes.py
# Python implementation of the Class WaitForChargeParameterDiscoveryRes
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:15:16
# Original author: Fabian.Stichtenoth
# 
#######################################################
import logging
import time

from shared.v2gMessages.msgDef.SAScheduleListType import SAScheduleListType
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.messageHandling.TerminateSession import TerminateSession
from shared.v2gMessages.msgDef.SignatureType import SignatureType
from shared.v2gMessages.msgDef.ChargeParameterDiscoveryResType import ChargeParameterDiscoveryResType
from shared.v2gMessages.msgDef.SAScheduleTupleType import SAScheduleTupleType
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from shared.v2gMessages.msgDef.EVSEProcessingType import EVSEProcessingType
from shared.v2gMessages.msgDef.EVSENotificationType import EVSENotificationType
from shared.v2gMessages.msgDef.ChargeProgressType import ChargeProgressType
from shared.v2gMessages.msgDef.ACEVSEChargeParameterType import ACEVSEChargeParameterType
from shared.v2gMessages.msgDef.DCEVSEChargeParameterType import DCEVSEChargeParameterType
from shared.v2gMessages.msgDef.EVSEStatusType import EVSEStatusType
from shared.misc.TimeRestrictions import TimeRestrictions
from shared.misc.State import State
from shared.utils.SecurityUtils import SecurityUtils
from shared.enumerations.V2GMessages import V2GMessages
from shared.enumerations.CPStates import CPStates
from shared.enumerations.GlobalValues import GlobalValues
from evcc.session.V2GCommunicationSessionEVCC import V2GCommunicationSessionEVCC
from evcc.states.ClientState import ClientState


class WaitForChargeParameterDiscoveryRes(ClientState):

    def __init__(self, comm_session_context: V2GCommunicationSessionEVCC):
        super().__init__(comm_session_context)

    @staticmethod
    def __delete_unverified_sales_tariffs(sa_schedules: SAScheduleListType) -> None:
        """If the signature of one ore more sales tariffs cannot be verified, then the
        sales tariffs should be ignored rather than terminating the charge process. The
        charge process can then proceed based solely on the PMaxSchedule
        :param sa_schedules: SAScheduleListType
        :return: None
        """
        sa_schedule_tuples = sa_schedules.get_sa_schedule_tuple()

        for sa_schedule_tuple in sa_schedule_tuples:
            sa_schedule_tuple.set_sales_tariff(None)

    def process_incoming_message(self, message) -> ReactionToIncomingMessage:
        """
        Initiates check if message is valid. If so, evse processing, evse processing type and comm session timer are
        checked. EVSE notification is set and dependent on it, message is processed. If there's a failure, session is
        terminated.
        :param message:
        :return: ReactionToIncomingMessage
        """
        if self.is_incoming_message_valid(message, ChargeParameterDiscoveryResType.__class__):
            v2g_message_res: V2GMessage = message
            charge_parameter_discovery_res: ChargeParameterDiscoveryResType = v2g_message_res.get_body(). \
                get_body_element().get_value()

            if charge_parameter_discovery_res.get_evse_processing() is None:
                return TerminateSession(
                    "EVSEProcessing parameter of ChargeParameterDiscoveryRes is null. Parameter is mandatory.")

            if charge_parameter_discovery_res.get_evse_processing() == EVSEProcessingType.ONGOING:
                logging.debug("EVSEProcessing was set to ONGOING")

            if self.get_comm_session_context().is_ongoing_timer_active():
                elapsed_time = time.time_ns() - self.get_comm_session_context().get_ongoing_timer()
                elapsed_time_in_ms = elapsed_time / 1000000

                if elapsed_time_in_ms > TimeRestrictions.V2G_EVCC_ONGOING_TIMEOUT:
                    return TerminateSession("Ongoing timer timed out for ChargeParameterDiscoveryReq")

            else:
                logging.debug("EVSEProcessing was set to FINISHED")

                self.get_comm_session_context().set_ongoing_timer(0)
                self.get_comm_session_context().set_ongoing_timer_active(False)

                try:
                    if str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("AC"):
                        evse_notification = charge_parameter_discovery_res.get_evse_charge_parameter().get_value(). \
                            get_ac_evse_status().get_evse_notification()

                    else:
                        evse_notification = charge_parameter_discovery_res.get_evse_charge_parameter().get_value(). \
                            get_dc_evse_status().get_evse_notification()

                except TypeError:
                    return TerminateSession("Sent EVSEChargeParameter do not match requested energy transfer mode " +
                                            str(self.get_comm_session_context().get_requested_energy_transfermode()))

                if evse_notification == EVSENotificationType.STOP_CHARGING:
                    logging.debug("The EVSE requested to stop the charging process")
                    self.get_comm_session_context().set_stop_charging_requested(True)

                    return self.get_send_message(self.get_power_delivery_req(ChargeProgressType.STOP),
                                                 V2GMessages.POWER_DELIVERY_RES)

                else:
                    sa_schedules = charge_parameter_discovery_res.get_sa_schedules().get_value()

                    if self.get_comm_session_context().is_tls_connection() and sa_schedules is not None:
                        if not self.__verify_sales_tariffs(sa_schedules, v2g_message_res.get_header().get_signature()):
                            logging.warning("The SalesTariff will be ignored for the charge process due to "
                                            + "failed signature verification during TLS communication.")
                            self.__delete_unverified_sales_tariffs(sa_schedules)

                    self.get_comm_session_context().set_sa_schedules(sa_schedules)

                    if self.get_comm_session_context().get_ev_controller().get_cp_state() == CPStates.STATE_B:
                        if str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("AC"):
                            return self.get_send_message(self.get_power_delivery_req(ChargeProgressType.START),
                                                         V2GMessages.POWER_DELIVERY_RES)

                        elif str(self.get_comm_session_context().get_requested_energy_transfermode).startswith("DC"):
                            if self.get_comm_session_context().get_ev_controller().set_cp_state(CPStates.STATE_C):
                                self.get_comm_session_context().set_ongoing_timer(time.time_ns())
                                self.get_comm_session_context().set_ongoing_timer_active(True)

                                return self.get_send_message(self.get_cable_check_req(), V2GMessages.CABLE_CHECK_RES)

                            else:
                                return TerminateSession(
                                    "CP state C not ready (current state = " +
                                    self.get_comm_session_context().get_ev_controller().get_cp_state() +
                                    ")")

                        else:
                            return TerminateSession(
                                "RequestedEnergyTransferMode '" + str(
                                    self.get_comm_session_context().get_requested_energy_transfermode()) +
                                "is neither of type AC nor DC")

                    else:
                        return TerminateSession(
                            "CP state B not ready (current state = " +
                            self.get_comm_session_context().get_ev_controller().get_cp_state() + ")")

        else:
            return TerminateSession("Incoming message raised an error")

    def __verify_sales_tariffs(self, sa_schedules: SAScheduleListType, signature: SignatureType) -> bool:
        """Verifies each sales tariff given with the ChargeParameterDiscoveryRes message
        with the mobility operator sub 2 certificate.
        :param sa_schedules: SAScheduleListType
        :param signature: SignatureType
        :return: bool that is True, if the verification of the sales tariffs was successful, false
        otherwise
        """
        if signature is None:
            sales_tariff_signature_available = False

        else:
            sales_tariff_signature_available = True

        if self.get_comm_session_context().is_tls_connection() and not sales_tariff_signature_available:
            ignore_sales_tariffs = True

        else:
            ignore_sales_tariffs = False

        ignored_sales_tariffs = 0

        verify_xml_sig_ref_elements = {}
        sa_schedule_tuples = sa_schedules.get_sa_schedule_tuple()
        sales_tariff_counter = 0

        for sa_schedule_tuple in sa_schedule_tuples:
            if sa_schedule_tuple.get_sales_tariff is None:
                continue

            if ignore_sales_tariffs:
                ignored_sales_tariffs += 1
                sa_schedule_tuple.set_sales_tariff(None)
                continue

            sales_tariff_counter += 1

            verify_xml_sig_ref_elements[sa_schedule_tuple.get_sales_tariff().get_id()] = SecurityUtils.generate_digest(
                sa_schedule_tuple.get_sales_tariff().get_id(),
                self.get_message_handler().get_jaxb_element(sa_schedule_tuple.get_sales_tariff()))

        if sales_tariff_counter > 0:
            mo_sub_ca2certificate = SecurityUtils.get_mo_sub_ca2certificate(str(GlobalValues.EVCC_KEYSTORE_FILEPATH))

            if mo_sub_ca2certificate is None:
                logging.error("No MOSubCA2 certificate found, signature of SalesTariff could therefore not be verified")
                return False

            else:
                if not SecurityUtils.verify_signature(signature, self.get_message_handler().get_jaxb_element(
                        signature.get_signed_info())):
                    # TODO: not sure how to implement getSubjectX500Principal
                    logging.warning("Verification of SalesTariff failed using certificate with distinguished name '" +
                                    mo_sub_ca2certificate.getSubjectX500Principal().__name__ + "'")
                    return False

        if ignored_sales_tariffs > 0:
            logging.info(
                "SalesTariffs could not be verified because of missing signature and will therefore be ignored")
            return False

        return True
