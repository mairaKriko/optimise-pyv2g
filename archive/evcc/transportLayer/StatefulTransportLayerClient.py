#######################################################
# 
# StatefulTransportLayerClient.py
# Python implementation of the Class StatefulTransportLayerClient
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:22:50
# Original author: Fabian.Stichtenoth
# 
#######################################################
import logging
import io

from shared.misc.V2GTPMessage import V2GTPMessage
from shared.messageHandling.TerminateSession import TerminateSession
from shared.utils.MiscUtils import MiscUtils


class StatefulTransportLayerClient:

    def __init__(self):
        self._v2g_tp_header: bytes = b''
        self._v2g_tp_payload: bytes = b''
        self._v2g_tp_message: bytes = b''
        self._in_stream = None
        self._out_stream = io.BytesIO(b"")
        self._mask: int = 0x80
        self._payload_length: int = 0
        self._bytes_read_from_input_stream: int = 0
        self._client_address = None
        self._client_port: int = 0
        self._timeout: int = 0
        self._stop_already_initiated: bool = False
        self.subscribers = set()

    def register(self, who):
        """
        Register (addObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.add(who)

    def unregister(self, who):
        """
        Unregister (deleteObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.discard(who)

    def dispatch(self, obj):
        """
        Dispatch method of Observer pattern. Calls update method in the subscriber class and makes reaction possible
        :return: None
        """
        for subscriber in self.subscribers:
            subscriber.update(obj)

    def get_bytes_read_from_input_stream(self) -> int:
        """
        Returns bytes read from input stream
        :return _bytes_read_from_input_stream: int
        """
        return self._bytes_read_from_input_stream

    def get_client_address(self):
        """
        Returns the address of the client (SECC)
        :return _client_address:
        """
        return self._client_address

    def get_client_port(self) -> int:
        """
        Returns the port of the client (SECC)
        :return _client_port: int
        """
        return self._client_port

    def get_in_stream(self):
        """
        Returns the input stream
        :return _in_stream:
        """
        return self._in_stream

    def get_mask(self) -> int:
        """
        Returns the mask
        :return _mask: int
        """
        return self._mask

    def get_out_stream(self):
        """
        Returns the output stream
        :return _out_stream:
        """
        return self._out_stream

    def get_payload_length(self) -> int:
        """
        Returns the payload length
        :return _payload_length: int
        """
        return self._payload_length

    def get_timeout(self) -> int:
        """
        Returns the timeout
        :return _timeout: int
        """
        return self._timeout

    def get_v2g_tp_header(self) -> bytes:
        """
        Returns the header
        :return _v2g_tp_header: bytes
        """
        return self._v2g_tp_header

    def get_v2g_tp_message(self) -> bytes:
        """
        Returns the message
        :return _v2g_tp_message: bytes
        """
        return self._v2g_tp_message

    def get_v2g_tp_payload(self) -> bytes:
        """
        Returns the payload
        :return _v2g_tp_payload: bytes
        """
        return self._v2g_tp_payload

    def initialize(self, host=None, port=None) -> None:
        """
        Initializes the client connection, sets port, address, header and timeout
        :param host:
        :param port:
        :return: None
        """
        logging.debug("Initializing client connection ...")
        self.set_client_port(MiscUtils.get_random_port_number())
        self.set_client_address(MiscUtils.get_link_local_address())
        self.set_v2g_tp_header(b'8')
        self.set_timeout(2000)

    def is_stop_already_initiated(self) -> bool:
        """
        Returns parameter that indicates if a stop was initiated
        :return _stop_already_initiated: bool
        """
        return self._stop_already_initiated

    def process_incoming_message(self) -> bool:
        """
        Tries to read from input stream and catches possible exceptions. Checks if bytes from input stream have
        reasonable payload length and if so, processes received message. Notifies Observer.
        :return: bool that is True if everything worked, False otherwise
        """
        try:
            self.set_bytes_read_from_input_stream(self.get_in_stream().read(self.get_v2g_tp_header()))

        except IOError as e:
            self.stop_and_notify("IOException occurred while trying to read the header of the incoming message. "
                                 + "Maybe timeout occurred?", e)
            return False

        except TypeError as e2:
            self.stop_and_notify(
                "NullPointerException occurred while trying to read the header of the incoming message", e2)
            return False

        if self.get_bytes_read_from_input_stream() < 0:
            self.stop_and_notify("No bytes read from input stream, server socket seems to be closed", None)
            return False

        if (self.get_v2g_tp_header()[4] & self.get_mask()) == self.get_mask():
            self.stop_and_notify("Payload length of V2GTP message is inappropriately high! There must be " +
                                 "an error in the V2GTP message header!", None)
            return False

        else:
            self.set_payload_length(int.from_bytes(self.get_v2g_tp_header()[4:8], byteorder='big'))
            self.set_v2g_tp_payload(bytes([self.get_payload_length()]))

            self.get_in_stream().read(self.get_v2g_tp_payload())
            logging.debug("Message received")

            self.set_v2g_tp_message(bytes([len(self.get_v2g_tp_header()) + len(self.get_v2g_tp_payload())]))

            self.get_v2g_tp_message()[0:len(self.get_v2g_tp_header())] = self.get_v2g_tp_header()[
                                                                     0:len(self.get_v2g_tp_header())]
            self.get_v2g_tp_message()[len(self.get_v2g_tp_header()):len(
                self.get_v2g_tp_payload())] = self.get_v2g_tp_payload()[0:len(self.get_v2g_tp_payload())]

        self.set_timeout(-1)

        self.dispatch(self.get_v2g_tp_message())

        return True

    def send(self, message: V2GTPMessage, timeout: int) -> None:
        pass

    def set_bytes_read_from_input_stream(self, bytes_read_from_input_stream: int) -> None:
        """
        Sets bytes read from input stream
        :param bytes_read_from_input_stream: int
        :return: None
        """
        self._bytes_read_from_input_stream = bytes_read_from_input_stream

    def set_client_address(self, client_address) -> None:
        """
        Sets the address of the client (SECC)
        :param client_address:
        :return: None
        """
        self._client_address = client_address

    def set_client_port(self, client_port: int) -> None:
        """
        Sets the port of the client (SECC)
        :param client_port: int
        :return: None
        """
        self._client_port = client_port

    def set_in_stream(self, in_stream) -> None:
        """
        Sets the input stream
        :param in_stream:
        :return: None
        """
        self._in_stream = in_stream

    def set_out_stream(self, out_stream) -> None:
        """
        Sets the output stream
        :param out_stream:
        :return: None
        """
        self._out_stream = out_stream

    def set_payload_length(self, payload_length: int) -> None:
        """
        Sets the payload length
        :param payload_length: int
        :return: None
        """
        self._payload_length = payload_length

    def set_stop_already_initiated(self, stop_already_initiated: bool) -> None:
        """
        Sets a parameter that indicates if a stop was already initiated
        :param stop_already_initiated: bool
        :return: None
        """
        self._stop_already_initiated = stop_already_initiated

    def set_timeout(self, timeout: int) -> None:
        """
        Sets the timeout
        :param timeout: int
        :return: None
        """
        self._timeout = timeout

    def set_v2g_tp_header(self, v2g_tp_header: bytes) -> None:
        """
        Sets the header
        :param v2g_tp_header: bytes
        :return: None
        """
        self._v2g_tp_header = v2g_tp_header

    def set_v2g_tp_message(self, v2g_tp_message) -> None:
        """
        Sets the message
        :param v2g_tp_message: bytes
        :return: None
        """
        self._v2g_tp_message = v2g_tp_message

    def set_v2g_tp_payload(self, v2g_tp_payload: bytes) -> None:
        """
        Sets the payload
        :param v2g_tp_payload: bytes
        :return: None
        """
        self._v2g_tp_payload = v2g_tp_payload

    def stop(self) -> None:
        pass

    def stop_and_notify(self, error_message: str, e) -> None:
        """If an error occurred in the run()-method, the TCP client will be stopped by
        closing all streams and the socket and interrupting the Thread.
        V2GCommunicationSessionEVCC will be notified as well. The method's statements
        will not be executed if a stop of the TCP client has already been initiated by
        the V2GCommunicationSessionEVCC (which might induce an error in the run()-
        method).
        :param e: Exception
        :param error_message: str
        :return: None
        """
        if not self.is_stop_already_initiated():
            logging.error(error_message, e)
            self.stop()
            self.set_stop_already_initiated(True)

            self.dispatch(TerminateSession(error_message))
