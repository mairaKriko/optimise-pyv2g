#######################################################
# 
# V2GCommunicationSessionSECC.py
# Python implementation of the Class V2GCommunicationSessionSECC
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:55:02
# Original author: Fabian.Stichtenoth
# 
#######################################################
import numpy as np
import logging

from secc.backend.DummyBackendInterface import DummyBackendInterface
from secc.evseController.DummyACEVSEController import DummyACEVSEController
from secc.evseController.DummyDCEVSEController import DummyDCEVSEController
from shared.v2gMessages.msgDef.ACEVSEStatusType import ACEVSEStatusType
from shared.v2gMessages.msgDef.CertificateChainType import CertificateChainType
from shared.v2gMessages.msgDef.EVSENotificationType import EVSENotificationType
from shared.v2gMessages.msgDef.EnergyTransferModeType import EnergyTransferModeType
from shared.v2gMessages.msgDef.MessageHeaderType import MessageHeaderType
from shared.v2gMessages.msgDef.MeterInfoType import MeterInfoType
from shared.v2gMessages.msgDef.PMaxScheduleType import PMaxScheduleType
from shared.v2gMessages.msgDef.PaymentOptionType import PaymentOptionType
from shared.v2gMessages.msgDef.ResponseCodeType import ResponseCodeType
from shared.v2gMessages.msgDef.SAScheduleListType import SAScheduleListType
from shared.v2gMessages.msgDef.ServiceType import ServiceType
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from secc.evseController.IACEVSEController import IACEVSEController
from shared.v2gMessages.msgDef.ACEVSEStatusType import ACEVSEStatusType
from secc.backend.IBackendInterface import IBackendInterface
from shared.v2gMessages.msgDef.ChargingSessionType import ChargingSessionType
from secc.transportLayer.ConnectionHandler import ConnectionHandler
from secc.evseController.IDCEVSEController import IDCEVSEController
from secc.evseController.IEVSEController import IEVSEController
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.messageHandling.SendMessage import SendMessage
from shared.messageHandling.ChangeProcessingState import ChangeProcessingState
from shared.messageHandling.TerminateSession import TerminateSession
from shared.misc.V2GCommunicationSession import V2GCommunicationSession
from shared.enumerations.V2GMessages import V2GMessages
from shared.v2gMessages.msgDef.ResponseCodeType import ResponseCodeType
from shared.misc.V2GTPMessage import V2GTPMessage
from shared.enumerations.GlobalValues import GlobalValues
from shared.messageHandling.MessageHandler import MessageHandler
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from secc.states.ForkState import ForkState
from secc.states.WaitForAuthorizationReq import WaitForAuthorizationReq
from secc.states.WaitForCableCheckReq import WaitForCableCheckReq
from secc.states.WaitForCertificateInstallationReq import WaitForCertificateInstallationReq
from secc.states.WaitForCertificateUpdateReq import WaitForCertificateUpdateReq
from secc.states.WaitForChargeParameterDiscoveryReq import WaitForChargeParameterDiscoveryReq
from secc.states.WaitForChargingStatusReq import WaitForChargingStatusReq
from secc.states.WaitForCurrentDemandReq import WaitForCurrentDemandReq
from secc.states.WaitForMeteringReceiptReq import WaitForMeteringReceiptReq
from secc.states.WaitForPaymentDetailsReq import WaitForPaymentDetailsReq
from secc.states.WaitForPaymentServiceSelectionReq import WaitForPaymentServiceSelectionReq
from secc.states.WaitForPowerDeliveryReq import WaitForPowerDeliveryReq
from secc.states.WaitForPreChargeReq import WaitForPreChargeReq
from secc.states.WaitForServiceDetailReq import WaitForServiceDetailReq
from secc.states.WaitForServiceDiscoveryReq import WaitForServiceDiscoveryReq
from secc.states.WaitForSessionSetupReq import WaitForSessionSetupReq
from secc.states.WaitForSessionStopReq import WaitForSessionStopReq
from secc.states.WaitForSupportedAppProtocolReq import WaitForSupportedAppProtocolReq
from secc.states.WaitForWeldingDetectionReq import WaitForWeldingDetectionReq


class V2GCommunicationSessionSECC(V2GCommunicationSession):

    def __init__(self, connection_handler):
        super().__init__()
        self._ac_evse_controller = None
        self._ac_evse_status = None
        self._backend_interface = None
        self._chosen_sa_schedule_tuple = None
        self._connection_handler = None
        self._contract_signature_cert_chain = None
        self._dc_evse_controller = None
        self._gen_challenge: bytes = b''
        self._incoming_v2g_tp_message: bytes = b''
        self._offered_services = []
        self._pause_v2g_communication_session: bool = False
        self._p_max_schedule = None
        self._requested_energy_transfermode = None
        self._sa_schedules = None
        self._schema_id = None
        self._selected_payment_option = None
        self._sent_meter_info = None
        self._charge_progress_started: bool = False
        self._old_session_joined: bool = False
        self._stop_v2g_communication_session: bool = False
        self.subscribers = set()

        self.set_connection_handler(connection_handler)

        connection_handler.register(self)

        self.get_states()[V2GMessages.FORK] = ForkState(self)
        self.get_states()[V2GMessages.SUPPORTED_APP_PROTOCOL_REQ] = WaitForSupportedAppProtocolReq(self)
        self.get_states()[V2GMessages.SESSION_SETUP_REQ] = WaitForSessionSetupReq(self)
        self.get_states()[V2GMessages.SERVICE_DISCOVERY_REQ] = WaitForServiceDiscoveryReq(self)
        self.get_states()[V2GMessages.SERVICE_DETAIL_REQ] = WaitForServiceDetailReq(self)
        self.get_states()[V2GMessages.PAYMENT_SERVICE_SELECTION_REQ] = WaitForPaymentServiceSelectionReq(self)
        self.get_states()[V2GMessages.CERTIFICATE_INSTALLATION_REQ] = WaitForCertificateInstallationReq(self)
        self.get_states()[V2GMessages.CERTIFICATE_UPDATE_REQ] = WaitForCertificateUpdateReq()
        self.get_states()[V2GMessages.PAYMENT_DETAILS_REQ] = WaitForPaymentDetailsReq(self)
        self.get_states()[V2GMessages.AUTHORIZATION_REQ] = WaitForAuthorizationReq(self)
        self.get_states()[V2GMessages.CHARGE_PARAMETER_DISCOVERY_REQ] = WaitForChargeParameterDiscoveryReq(self)
        self.get_states()[V2GMessages.CABLE_CHECK_REQ] = WaitForCableCheckReq(self)
        self.get_states()[V2GMessages.PRE_CHARGE_REQ] = WaitForPreChargeReq(self)
        self.get_states()[V2GMessages.POWER_DELIVERY_REQ] = WaitForPowerDeliveryReq(self)
        self.get_states()[V2GMessages.CHARGING_STATUS_REQ] = WaitForChargingStatusReq(self)
        self.get_states()[V2GMessages.CURRENT_DEMAND_REQ] = WaitForCurrentDemandReq(self)
        self.get_states()[V2GMessages.METERING_RECEIPT_REQ] = WaitForMeteringReceiptReq(self)
        self.get_states()[V2GMessages.WELDING_DETECTION_REQ] = WaitForWeldingDetectionReq(self)
        self.get_states()[V2GMessages.SESSION_STOP_REQ] = WaitForSessionStopReq(self)

        self.set_start_state(self.get_states().get(V2GMessages.SUPPORTED_APP_PROTOCOL_REQ))
        self.set_current_state(self.get_start_state())

        self.set_ac_evse_controller(DummyACEVSEController(self))
        self.set_dc_evse_controller(DummyDCEVSEController(self))

        self.set_backend_interface(DummyBackendInterface(self))

        self.set_ac_evse_status(ACEVSEStatusType())
        self.get_ac_evse_status().set_evse_notification(EVSENotificationType.NONE)
        self.get_ac_evse_status().set_notification_max_delay(0)
        self.get_ac_evse_status().set_rcd(False)

        self.set_stop_v2g_communication_session(False)
        self.set_pause_v2g_communication_session(False)

        list1 = []
        self.set_offered_services(list1)

        logging.debug("\n*******************************************" +
                      "\n* New V2G communication session initialized" +
                      "\n*******************************************")
        pass

    def register(self, who):
        """
        Register (addObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.add(who)

    def unregister(self, who):
        """
        Unregister (deleteObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.discard(who)

    def dispatch(self):
        """
        Dispatch method of Observer pattern. Calls update method in the subscriber class and makes reaction possible
        :return: None
        """
        for subscriber in self.subscribers:
            subscriber.update()

    def check_session_id(self, header):
        """Returns a response code according to 8.4.2
        :param header:
        :return: ResponseCodeType; The corresponding response code
        """
        if self.get_current_state() == self.get_states().get(V2GMessages.SESSION_SETUP_REQ) and \
                int.from_bytes(header.get_session_id(), byteorder='big') == 0:
            self.set_session_id(self.generate_session_id_randomly())
            self.set_old_session_joined(False)
            return ResponseCodeType.OK_NEW_SESSION_ESTABLISHED

        elif self.get_current_state() == self.get_states().get(V2GMessages.SESSION_SETUP_REQ) and \
                header.get_session_id() == self.get_session_id():
            self.set_old_session_joined(True)
            return ResponseCodeType.OK_OLD_SESSION_JOINED

        elif self.get_current_state() == self.get_states().get(V2GMessages.SESSION_SETUP_REQ) and \
                int.from_bytes(header.get_session_id(), byteorder='big') != 0 and \
                header.get_session_id() != self.get_session_id():
            self.set_session_id(self.generate_session_id_randomly())
            self.set_old_session_joined(False)
            return ResponseCodeType.OK_NEW_SESSION_ESTABLISHED

        elif np.array_equal(header.get_session_id(), self.get_session_id()):
            self.set_old_session_joined(False)
            return ResponseCodeType.OK

        else:
            self.set_old_session_joined(False)
            return ResponseCodeType.FAILED_UNKNOWN_SESSION

    def get_ac_evse_controller(self):
        """
        Returns the evse controller for AC
        :return _ac_evse_controller:
        """
        return self._ac_evse_controller

    def get_ac_evse_status(self):
        """
        Returns the evse status for AC
        :return _ac_evse_status:
        """
        return self._ac_evse_status

    def get_backend_interface(self):
        """
        Returns the backend interface
        :return _backend_interface:
        """
        return self._backend_interface

    def get_chosen_sa_schedule_tuple(self):
        """
        Returns the chosen SA schedule
        :return _chosen_sa_schedule_tuple:
        """
        return self._chosen_sa_schedule_tuple

    def get_connection_handler(self):
        """
        Returns the connection handler
        :return _connection_handler:
        """
        return self._connection_handler

    def get_contract_signature_cert_chain(self):
        """
        Returns the contract signature cert chain
        :return _contract_signature_cert_chain:
        """
        return self._contract_signature_cert_chain

    def get_dc_evse_controller(self):
        """
        Returns the dc evse controller
        :return _dc_evse_controller:
        """
        return self._dc_evse_controller

    def get_evse_controller(self):
        """
        Returns the evse controller, dependent on the transfermode
        :return _ac_evse_controller:
        """
        if self.get_requested_energy_transfermode() is not None:
            if str(self.get_requested_energy_transfermode()).startswith("AC"):
                return self._ac_evse_controller

            elif str(self.get_requested_energy_transfermode()).startswith("DC"):
                return self._dc_evse_controller

            else:
                logging.error("RequestedEnergyTransferMode '" +
                              str(self.get_requested_energy_transfermode()) +
                              "is neither of type AC nor DC")
                return None

        else:
            return self._ac_evse_controller

    def get_gen_challenge(self):
        """
        Returns the Gen Challenge
        :return _gen_challenge:
        """
        return self._gen_challenge

    def get_incoming_v2g_tp_message(self):
        """
        Returns the incoming message
        :return _incoming_v2g_tp_message:
        """
        return self._incoming_v2g_tp_message

    def get_offered_services(self):
        """
        Returns the offered services
        :return _offered_services:
        """
        return self._offered_services

    def get_p_max_schedule(self):
        """
        Returns the PMax Schedule
        :return _p_max_schedule:
        """
        return self._p_max_schedule

    def get_requested_energy_transfermode(self):
        """
        Returns the requested energy transfermode
        :return _requested_energy_transfermode:
        """
        return self._requested_energy_transfermode

    def get_sa_schedules(self):
        """
        Returns the SA schedules
        :return _sa_schedules:
        """
        return self._sa_schedules

    def get_schema_id(self):
        """
        Returns the schema id
        :return _schema_id:
        """
        return self._schema_id

    def get_selected_payment_option(self):
        """
        Returns the selected payment option
        :return _selected_payment_option:
        """
        return self._selected_payment_option

    def get_sent_meter_info(self):
        """
        Returns the sent meter info
        :return _sent_meter_info:
        """
        return self._sent_meter_info

    def is_charge_progress_started(self):
        """
        Returns a parameter that indicates if charging has started
        :return _charge_progress_started: bool
        """
        return self._charge_progress_started

    def is_old_session_joined(self):
        """
        Returns a parameter that indicates if an old session was joined
        :return _old_session_joined: bool
        """
        return self._old_session_joined

    def is_pause_v2g_communication_session(self):
        """
        Returns a parameter that indicates if the communication session is paused
        :return _pause_v2g_communication_session: bool
        """
        return self._pause_v2g_communication_session

    def is_stop_v2g_communication_session(self):
        """
        Returns a parameter that indicates if the communication session is stopped
        :return _stop_v2g_communication_session: bool
        """
        return self._stop_v2g_communication_session

    def process_incoming_message(self, incoming_message):
        """
        Checks if message is valid and payload is as expected. Then decides if message is SUPPORTED_APP_PROTOCOL_REQ or
        other and processes reaction accordingly. If there's an failure, session is terminated
        :param incoming_message:
        :return: None
        """
        self.set_v2g_tp_message(V2GTPMessage(incoming_message))

        if self.get_message_handler().is_v2g_tp_message_valid(self.get_v2g_tp_message()) and np.array_equal(
                self.get_v2g_tp_message().get_payload_type(),
                GlobalValues.V2GTP_PAYLOAD_TYPE_EXI_ENCODED_V2G_MESSAGE.get_byte_array_value()):
            if self.get_current_state() == self.get_states().get(V2GMessages.SUPPORTED_APP_PROTOCOL_REQ):
                incoming_message = self.get_message_handler().exi_to_supp_app_protocol_msg(
                    self.get_v2g_tp_message().get_payload())

            else:
                incoming_message = self.get_message_handler().exi_to_v2g_msg(self.get_v2g_tp_message().get_payload())

            self.__process_reaction(self.get_current_state().process_incoming_message(incoming_message))

        else:
            self.terminate_session("Received incoming message is not a valid V2GTPMessage", False)
        pass

    def __process_reaction(self, reaction_to_incoming_message):
        """
        Checks if reaction to the message should be sending a message, changing the processing state or terminating the
        session and acts accordingly
        :param reaction_to_incoming_message:
        :return: None
        """
        if isinstance(reaction_to_incoming_message, SendMessage):
            self.send(reaction_to_incoming_message)
            if self.is_stop_v2g_communication_session():
                self.terminate_session(
                    "EVCC indicated request to stop the session or a FAILED response code was sent", True)

        elif isinstance(reaction_to_incoming_message, ChangeProcessingState):
            self.set_current_state(reaction_to_incoming_message).get_new_state()
            self.__process_reaction(
                self.get_current_state().process_incoming_message(reaction_to_incoming_message).get_payload())

        elif isinstance(reaction_to_incoming_message, TerminateSession):
            self.terminate_session(reaction_to_incoming_message)

        else:
            self.terminate_session("Reaction to incoming message is undefined", False)
        pass

    def send(self, send_message):
        """
        Sets payload to prepare sending a message and initiates the sending
        :param send_message:
        :return: None
        """
        if isinstance(send_message.get_payload(), V2GMessage):
            payload = self.get_message_handler().v2g_msg_to_exi(send_message.get_payload())

        else:
            payload = self.get_message_handler().supp_app_protocol_msg_to_exi(send_message.get_payload())

        self.set_v2g_tp_message(V2GTPMessage(
            GlobalValues.V2GTP_VERSION_1_IS.get_byte_value(),
            GlobalValues.V2GTP_PAYLOAD_TYPE_EXI_ENCODED_V2G_MESSAGE.get_byte_array_value(),
            payload))

        self.get_connection_handler().send(self.get_v2g_tp_message())

        if send_message.get_next_state(self) is not None:
            self.set_current_state(send_message.get_next_state())

        else:
            logging.info("State machine has come to an end, no new state provided")
        pass

    def set_ac_evse_controller(self, ac_evse_controller):
        """
        Sets the evse controller for AC
        :param ac_evse_controller:
        :return: None
        """
        self._ac_evse_controller = ac_evse_controller

    def set_ac_evse_status(self, ac_evse_status):
        """
        Sets the evse status for AC
        :param ac_evse_status:
        :return: None
        """
        self._ac_evse_status = ac_evse_status

    def set_backend_interface(self, backend_interface):
        """
        Sets the backend interface
        :param backend_interface:
        :return: None
        """
        self._backend_interface = backend_interface

    def set_charge_progress_started(self, charge_progress_started):
        """
        Sets an parameter that indicates if the charge session was started
        :param charge_progress_started:
        :return: None
        """
        self._charge_progress_started = charge_progress_started

    def set_chosen_sa_schedule_tuple(self, sa_schedule_tuple_id):
        """
        Sets the chosen SA schedule
        :param sa_schedule_tuple_id:
        :return: None
        """
        self._chosen_sa_schedule_tuple = sa_schedule_tuple_id

    def set_connection_handler(self, connection_handler):
        """
        Sets the connection handler map
        :param connection_handler:
        :return: None
        """
        self._connection_handler = connection_handler

    def set_contract_signature_cert_chain(self, contract_signature_cert_chain):
        """
        Sets the contract signature cert chain
        :param contract_signature_cert_chain:
        :return: None
        """
        self._contract_signature_cert_chain = contract_signature_cert_chain

    def set_dc_evse_controller(self, dc_evse_controller):
        """
        Sets the evse controller for DC
        :param dc_evse_controller:
        :return: None
        """
        self._dc_evse_controller = dc_evse_controller

    def set_gen_challenge(self, gen_challenge):
        """
        Sets the gen challenge
        :param gen_challenge:
        :return: None
        """
        self._gen_challenge = gen_challenge

    def set_incoming_v2g_tp_message(self, incoming_v2g_tp_message):
        """
        Sets the incoming message
        :param incoming_v2g_tp_message:
        :return: None
        """
        self._incoming_v2g_tp_message = incoming_v2g_tp_message

    def set_offered_services(self, offered_services):
        """
        Sets the offered services
        :param offered_services:
        :return: None
        """
        self._offered_services = offered_services

    def set_old_session_joined(self, old_session_joined):
        """
        Sets a parameter that indicates if an old session was joined
        :param old_session_joined: bool
        :return: None
        """
        self._old_session_joined = old_session_joined

    def set_pause_v2g_communication_session(self, pause_v2g_communication_session):
        """
        Sets a parameter that indicates if the communication session was paused
        :param pause_v2g_communication_session:
        :return: None
        """
        self._pause_v2g_communication_session = pause_v2g_communication_session

    def set_p_max_schedule(self, new_p_max_schedule):
        """
        Sets the PMax schedule
        :param new_p_max_schedule:
        :return: None
        """
        self._p_max_schedule = new_p_max_schedule

    def set_requested_energy_transfermode(self, requested_energy_transfermode):
        """
        Sets the requested energy transfermode
        :param requested_energy_transfermode:
        :return: None
        """
        self._requested_energy_transfermode = requested_energy_transfermode

    def set_sa_schedules(self, sa_schedules):
        """
        Sets the SA schedules
        :param sa_schedules:
        :return: None
        """
        self._sa_schedules = sa_schedules

    def set_schema_id(self, schema_id):
        """
        Sets the schema ID
        :param schema_id:
        :return: None
        """
        self._schema_id = schema_id

    def set_selected_payment_option(self, selected_payment_option):
        """
        Sets the selected payment option (Contract, External)
        :param selected_payment_option:
        :return: None
        """
        self._selected_payment_option = selected_payment_option

    def set_sent_meter_info(self, sent_meter_info):
        """
        Sets the sent meter info
        :param sent_meter_info:
        :return: None
        """
        self._sent_meter_info = sent_meter_info

    def set_stop_v2g_communication_session(self, stop_v2g_communication_session):
        """
        Sets a parameter that indicates if the communication session was stopped
        :param stop_v2g_communication_session:
        :return: None
        """
        self._stop_v2g_communication_session = stop_v2g_communication_session

    def update(self, obs, obj):
        """
        Checks if obj is of type bytes or None. If bytes, incoming message is processed. If None, session is terminated
        :param obs:
        :param obj:
        :return:
        """
        if isinstance(obs, ConnectionHandler) and isinstance(obj, bytes):
            self.process_incoming_message(obj)

        elif isinstance(obs, ConnectionHandler) and obj is None:
            self.terminate_session("ConnectionHandler has notified an error", False)
