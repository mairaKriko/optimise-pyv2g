#######################################################
# 
# V2GCommunicationSessionHandlerSECC.py
# Python implementation of the Class V2GCommunicationSessionHandlerSECC
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:54:46
# Original author: Fabian.Stichtenoth
# 
#######################################################
import threading
import logging
import socket
from typing import Dict, Any

from shared.messageHandling.MessageHandler import MessageHandler
from shared.misc.V2GTPMessage import V2GTPMessage
from shared.misc.V2GCommunicationSession import V2GCommunicationSession
from shared.messageHandling.TerminateSession import TerminateSession
from shared.enumerations.GlobalValues import GlobalValues
from shared.v2gMessages.SECCDiscoveryReq import SECCDiscoveryReq
from shared.v2gMessages.SECCDiscoveryRes import SECCDiscoveryRes
from shared.utils.ByteUtils import ByteUtils
from secc.transportLayer.UDPServer import UDPServer
from secc.transportLayer.TCPServer import TCPServer
from secc.transportLayer.TLSServer import TLSServer
from secc.transportLayer.StatefulTransportLayerServer import StatefulTransportLayerServer
from secc.session.V2GCommunicationSessionSECC import V2GCommunicationSessionSECC
from secc.transportLayer.ConnectionHandler import ConnectionHandler


class V2GCommunicationSessionHandlerSECC:

    def __init__(self):
        self._connection_handler_map = {}
        self._message_handler = None
        self._security = b''
        self._v2g_communication_sessions = {}
        self._v2g_tp_message = None
        # self.subscribers = set()

        UDPServer.get_instance().register(self)
        TCPServer.get_instance().register(self)
        TLSServer.get_instance().register(self)

        map1 = {}
        self.set_v2g_communication_sessions(map1)

        map2 = {}
        self.set_connection_handler_map(map2)

        self.set_message_handler(MessageHandler())

    def get_connection_handler_map(self):
        """
        Returns the connection handler map
        :return _connection_handler_map:
        """
        return self._connection_handler_map

    def get_message_handler(self):
        """
        Returns the message handler
        :return _message_handler: MessageHandler
        """
        return self._message_handler

    def get_security(self):
        """
        Returns the security value of type bytes
        :return _security: bytes
        """
        return self._security

    def get_v2g_communication_sessions(self):
        """
        Returns a map of active communication sessions
        :return _v2g_communication_sessions:
        """
        return self._v2g_communication_sessions

    def get_v2g_tp_message(self):
        """
        Returns the V2G-TransportProtocol-Message
        :return _v2g_tp_message:
        """
        return self._v2g_tp_message

    def is_secure_communication(self):
        """
        Checks if the security of communication is correct
        :return: bool that indicates True when security is correct and False otherwise
        """
        return self.get_security() == GlobalValues.V2G_SECURITY_WITH_TLS.get_byte_value()

    def __manage_connection_handlers(self, connection_handler):
        """
        Creates a new thread for the conncetion handler, starts it and logs it in a dict
        :param connection_handler:
        :return: None
        """
        connection_handler_thread = threading.Thread(target=connection_handler,
                                                     name="ConnectionThread " +
                                                          ConnectionHandler.get_address(connection_handler),
                                                     # TODO: not sure if correct -> testing!
                                                     daemon=True)
        connection_handler_thread.start()

        self.get_connection_handler_map()[connection_handler] = connection_handler_thread
        pass

    def __process_secc_discovery_req(self, udp_client_packet):
        """
        Checks if SECCDiscoveryReq-message is valid. Creates SECCDiscoveryRes and sends it
        :param udp_client_packet:
        :return: None
        """
        self.set_v2g_tp_message(V2GTPMessage(udp_client_packet.recv(4096)))

        try:
            if self.get_message_handler().is_v2g_tp_message_valid(self.get_v2g_tp_message()) \
                    and self.get_v2g_tp_message().get_payload_type() == GlobalValues.\
                    V2GTP_PAYLOAD_TYPE_SDP_REQUEST_MESSAGE.get_byte_array_value():
                secc_discovery_req = SECCDiscoveryReq(self.get_v2g_tp_message().get_payload())
                self.set_security(secc_discovery_req.get_security())
                logging.debug("SECCDiscoveryReq received")

                if self.is_secure_communication():
                    secc_address = TLSServer.get_instance().get_server_address().getsockname()[0]
                    secc_port = TLSServer.get_instance().get_server_port()

                else:
                    secc_address = TCPServer.get_instance().get_server_address().getsockname()[0]
                    secc_port = TCPServer.get_instance().get_server_port()

                # TODO: not sure if struct.unpack works here for ByteUtils.to_byte_array_from_int or how to do it
                secc_discovery_res = SECCDiscoveryRes(secc_address, ByteUtils.to_byte_array_from_int(secc_port, True),
                                                      self.get_security(),
                                                      GlobalValues.V2G_TRANSPORT_PROTOCOL_TCP.get_byte_value())

                self.set_v2g_tp_message(
                    V2GTPMessage(GlobalValues.V2GTP_VERSION_1_IS.get_byte_value(),
                                 GlobalValues.V2GTP_PAYLOAD_TYPE_SDP_RESPONSE_MESSAGE.get_byte_array_value(),
                                 secc_discovery_res.get_payload()))

                logging.debug("Preparing to send SECCDiscoveryRes ...")

                UDPServer.get_instance().sendto(self.get_v2g_tp_message(), udp_client_packet.gethostbyname(),
                                                udp_client_packet.getsockname())

            else:
                logging.warning("Incoming DatagramPacket could not be identified as an SECCDiscoveryReq")

        except TypeError as e:
            logging.error("NullPointerException occurred while processing SECCDiscoveryReq", e)
        pass

    def remove_v2g_communication_session(self, requester_address):
        """
        Deletes session of requester_address from respective dict
        :param requester_address:
        :return: None
        """
        del self.get_v2g_communication_sessions()[self.get_v2g_communication_sessions().get(requester_address)]

    def set_connection_handler_map(self, connection_handler_map):
        """
        Sets the connection handler map
        :param connection_handler_map:
        :return: None
        """
        self._connection_handler_map = connection_handler_map

    def set_message_handler(self, message_handler):
        """
        Sets the message handler
        :param message_handler:
        :return: None
        """
        self._message_handler = message_handler

    def set_security(self, security):
        """
        Sets the security
        :param security:
        :return: None
        """
        self._security = security

    def set_v2g_communication_sessions(self, v2g_communication_sessions):
        """
        Sets a map of active communication sessions
        :param v2g_communication_sessions:
        :return: None
        """
        self._v2g_communication_sessions = v2g_communication_sessions

    def set_v2g_tp_message(self, v2g_tp_message):
        self._v2g_tp_message = v2g_tp_message

    def stop_connection_handler(self, connection_handler):
        """Stops (interrupts) the respective thread running the provided ConnectionHandler
        and tries to close its socket.
        :param connection_handler:
        :return: None
        """
        if connection_handler in self.get_connection_handler_map():
            connection_handler.stop()

            connection_thread = self.get_connection_handler_map().get(connection_handler)
            connection_thread.interrupt()

            del self.get_connection_handler_map()[connection_handler]

            logging.debug("Thread '" + connection_thread.__name__ + "' has been interrupted and removed\n\n")

        else:
            address = connection_handler.get_address(self)
            port = connection_handler.get_port(self)

            logging.warning("No active connection to socket with IP address " + address + " and port " +
                            port + " found.")

    def update(self, obs, obj):
        """
        Checks if obs is of instance UDPServer or TCPServer/TLSServer. If UDPServer, then SECCDiscoveryReq is processed.
        IP address is taken and checked. If the address is within the active session, session is continued and TLS is
        either en- or disabled. If not, a new session is created. If obs is neither of instance UDPServer nor instance
        TCPServer/TLSServer, the address is deleted from the list of active sessions and the connection handler is
        stopped
        :param obs:
        :param obj:
        :return: None
        """
        if isinstance(obs, UDPServer) and isinstance(obj, socket.socket):
            self.__process_secc_discovery_req(obj)

        elif isinstance(obs, TCPServer) or isinstance(obs, TLSServer) and isinstance(obj, ConnectionHandler):
            ip_address = obj.get_address()

            if ip_address in self.get_v2g_communication_sessions():
                continued_session = self.get_v2g_communication_sessions().get(ip_address)
                continued_session.set_connection_handler(obs)
                if isinstance(obs, TLSServer):
                    continued_session.set_tls_connection(True)
                else:
                    continued_session.set_tls_connection(False)

                obj.register(self.get_v2g_communication_sessions().get(ip_address))

                self.__manage_connection_handlers(obj)

            else:
                new_session = V2GCommunicationSessionSECC(obj)
                if isinstance(obs, TLSServer):
                    new_session.set_tls_connection(True)
                else:
                    new_session.set_tls_connection(False)
                    new_session.register(self)

                self.get_v2g_communication_sessions()[ip_address] = new_session

                self.__manage_connection_handlers(obj)

        elif isinstance(obs, V2GCommunicationSessionSECC) and isinstance(obj, TerminateSession):
            ip_address = obs.get_connection_handler().get_address()
            del self.get_v2g_communication_sessions()[ip_address]

            self.stop_connection_handler(obs.get_connection_handler())

        else:
            logging.warning("Notification received, but sending entity or received object not identifiable")
