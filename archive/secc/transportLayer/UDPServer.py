#######################################################
#
# UDPServer.py
# Python implementation of the Class UDPServer
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 12:07:11
# Original author: Fabian.Stichtenoth
#
#######################################################
from shared.misc.V2GTPMessage import V2GTPMessage
from shared.utils.MiscUtils import MiscUtils
from shared.enumerations.GlobalValues import GlobalValues

import socket
import struct
import logging
import threading

_unique_udp_server_instance = None


class UDPServer:
    """The UDP server is handling the SECCDiscovery messages only. The standard does
    not foresee any further communication to be done via UDP but TCP. Therefore,
    the size of the UPD packet to be received is restricted to 10 bytes (8 bytes
    header of V2GTP message + 2 byte SECCDiscoveryReq payload).
    """

    # Eager instantiation of the Singleton, since a UDP server is always needed up
    # front. The JVM creates the unique instance when the class is loaded and before
    # any thread tries to access the instance variable -> thread safe.

    def __init__(self):
        self._multicast_address = None
        self._udp_client_packet = None
        self._udp_client_request = None
        self._udp_server_address = None
        self._udp_server_socket = None
        self._unique_udp_server_instance = UDPServer()
        self._interrupt = False
        self.mreq = None
        self.subscribers = set()

    # TODO: is implementation of Observer pattern correct?
    def register(self, who):
        """
        Register (addObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.add(who)

    def unregister(self, who):
        """
        Unregister (deleteObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.discard(who)

    def dispatch(self, obj):
        """
        Dispatch method of Observer pattern. Calls update method in the subscriber class and makes reaction possible
        :return: None
        """
        for subscriber in self.subscribers:
            subscriber.update(obj)

    @classmethod
    def get_instance(cls):
        """
        Checks if an _unique_udp_server_instance already exists and initializes one if not
        :return _unique_udp_server_instance:
        """
        global _unique_udp_server_instance
        if _unique_udp_server_instance is None:
            _unique_udp_server_instance = UDPServer()
        return _unique_udp_server_instance

    def get_multicast_address(self):
        """
        Returns the _multicast_address
        :return _multicast_address:
        """
        return self._multicast_address

    def get_udp_client_packet(self):
        """
        Returns the _udp_client_packet
        :return _udp_client_packet:
        """
        return self._udp_client_packet

    def get_udp_client_request(self):
        """
        Returns the _udp_client_request
        :return _udp_client_request:
        """
        return self._udp_client_request

    def get_udp_server_address(self):
        """
        Returns the _udp_server_address
        :return _udp_server_address:
        """
        return self._udp_server_address

    def get_udp_server_socket(self):
        """
        Returns the _udp_server_socket
        :return _udp_server_socket:
        """
        return self._udp_server_socket

    def initialize(self):
        """Used to check the correct initialization of a UDP server which is a prerequisite for establishing a V2G
        communication session.
        :return: bool; True if the initialization of the UDP server was successful, False otherwise
        """

        self.set_udp_client_request(bytearray(10))

        try:
            self.__set_udp_server_address(MiscUtils.get_link_local_address())

            if self.get_udp_server_address() is None:
                return False

            self.set_multicast_address(socket.gethostbyname(str(GlobalValues.SDP_MULTICAST_ADDRESS)))

            multicast_group = self.get_multicast_address()
            server_address = (self.get_udp_server_address(), GlobalValues.V2G_UDP_SDP_SERVER_PORT.get_short_value())

            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

            sock.bind(server_address)

            group = socket.inet_aton(multicast_group)
            self.mreq = struct.pack('4sL', group, socket.INADDR_ANY)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, self.mreq)

            self.set_udp_server_socket(sock)

            # TODO: not sure how to implement the following two lines
            # getUdpServerSocket().setInterface(getUdpServerAddress())
            # getUdpServerSocket().joinGroup(getMulticastAddress())

            logging.info("UDP server initialized at link-local address " + socket.gethostbyname(
                self.get_udp_server_address()) + " and port 15118")

        except socket.herror as e:
            logging.error("Unknown host exception was thrown!", e)
            return False
        except IOError as e:
            logging.error("MulticastSocket creation failed!", e)
            return False

        return True

    def run(self):
        """
        Checks that session isn't interrupted, accepts incoming connection, logs address and socket and notifies
        observer
        :return: None
        """
        while not self._interrupt:

            try:
                self.get_udp_server_socket().recv(len(self._udp_client_request))
                logging.debug("Message received")

                # TODO: not sure if implementation of the following line is correct
                self.dispatch(self.get_udp_client_packet())
            except socket.herror as e:
                logging.error("SocketException", e)
            except IOError as e:
                logging.error("IOException", e)
                self.get_udp_server_socket().close()

        self.stop()
        pass

    def send(self, message: V2GTPMessage, udp_client_address, udp_client_port):
        """
        Gets the message and tries to send it. Returns True if it was successful, False otherwise
        :param message: V2GTPMessage
        :param udp_client_address:
        :param udp_client_port:
        :return: bool
        """
        v2gTPMessage = message.get_message()

        try:
            self._udp_server_socket.sendto(bytes(v2gTPMessage, "utf-8"), (udp_client_address, udp_client_port))
            logging.debug("Message sent")

            return True

        except IOError as e:
            logging.error("UDP response failed (IOException) while trying to send message!", e)
            return False

    def set_multicast_address(self, multicast_address):
        """
        Sets the _multicast_address
        :param multicast_address:
        :return: None
        """
        self._multicast_address = multicast_address
        pass

    def set_udp_client_packet(self, udp_client_packet):
        """
        Sets the _udp_client_packet
        :param udp_client_packet:
        :return: None
        """
        self._udp_client_packet = udp_client_packet
        pass

    def set_udp_client_request(self, udp_client_request):
        """
        Sets the _udp_client_request
        :param udp_client_request:
        :return: None
        """
        self._udp_client_request = udp_client_request
        pass

    def __set_udp_server_address(self, udp_server_address):
        """
        Sets the _udp_server_address
        :param udp_server_address:
        :return: None
        """
        self._udp_server_address = udp_server_address
        pass

    def set_udp_server_socket(self, udp_server_socket):
        """
        Sets the _udp_server_socket
        :param udp_server_socket:
        :return: None
        """
        self._udp_server_socket = udp_server_socket
        pass

    def stop(self):
        """
        Closes udp socket
        :return: None
        """
        logging.debug("UDP server will be stopped now")

        try:
            self.get_udp_server_socket().setsockopt(socket.IPPROTO_IP, socket.IP_DROP_MEMBERSHIP, self.mreq)

        except IOError as e:
            logging.error("Error occurred while trying to close TCPServerSocket (IOException)", e)

        self.get_udp_server_socket().close()
        logging.debug("UDP server stopped (socket closed)")
        pass
