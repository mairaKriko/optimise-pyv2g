#######################################################
# 
# TCPServer.py
# Python implementation of the Class TCPServer
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 12:06:40
# Original author: Fabian.Stichtenoth
# 
#######################################################
from secc.transportLayer.StatefulTransportLayerServer import StatefulTransportLayerServer
from secc.transportLayer.ConnectionHandler import ConnectionHandler

import logging
import socket
import threading

_unique_tcp_server_instance = None


class TCPServer(StatefulTransportLayerServer):

    def __init__(self):
        super().__init__()
        self._tcp_client_socket = None
        self._tcp_server_socket = None
        self._unique_tcp_server_instance = TCPServer()
        self._interrupt = False
        self.subscribers = set()

    # TODO: is implementation of Observer pattern correct?
    def register(self, who):
        """
        Register (addObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.add(who)

    def unregister(self, who):
        """
        Unregister (deleteObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.discard(who)

    def dispatch(self, obj):
        """
        Dispatch method of Observer pattern. Calls update method in the subscriber class and makes reaction possible
        :return: None
        """
        for subscriber in self.subscribers:
            subscriber.update(obj)

    @classmethod
    def get_instance(cls):
        """
        Checks if an _unique_tcp_server_instance already exists and initializes one if not
        :return _unique_tcp_server_instance:
        """
        global _unique_tcp_server_instance
        if _unique_tcp_server_instance is None:
            _unique_tcp_server_instance = TCPServer()
        return _unique_tcp_server_instance

    def get_tcp_client_socket(self):
        """
        Returns the _tcp_client_socket
        :return _tcp_client_socket:
        """
        return self._tcp_client_socket

    def get_tcp_server_socket(self):
        """
        Returns the _tcp_server_socket
        :return _tcp_server_socket:
        """
        return self._tcp_server_socket

    def initialize(self):
        """
        Used to check the correct initialization of a TCP server which is a prerequisite for establishing a V2G
        communication session.
        :return: bool
        """
        super().initialize()

        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.bind((self.get_server_address(), self.get_server_port()))
            s.listen(50)
            self.set_tcp_server_socket(s)
            logging.info("TCP server initialized at link-local address " +
                         self.get_tcp_server_socket().gethostname() +
                         " and port " + self.get_tcp_server_socket().getsockname()[1])

        except IOError as e:
            logging.fatal("IOException while trying to initialize TCP server", e)
            return False

        return True

    def run(self):
        """
        Checks that session isn't interrupted, accepts incoming connection, logs address and socket and notifies
        observer
        :return: None
        """
        try:
            while not self._interrupt:
                logging.info("Waiting for new TCP client connection ...")
                self.set_tcp_client_socket(self.get_tcp_server_socket().accept())

                logging.info("TCP client connection with IP address " +
                             self.get_tcp_client_socket().gethostname() + " and port " +
                             self.get_tcp_client_socket().getsockname()[1])

                connectionHandler = ConnectionHandler(self._tcp_client_socket, socket_type="tcp")

                # TODO: not sure if implementation of the following line is correct
                self.dispatch(connectionHandler)

        except IOError as e:
            logging.error(e.__class__.__name__ + " occurred while running TCPServer")
        finally:
            self.stop()

    def set_tcp_client_socket(self, tcp_client_socket):
        """
        Sets the _tcp_client_socket
        :param tcp_client_socket:
        :return: None
        """
        self._tcp_client_socket = tcp_client_socket

    def set_tcp_server_socket(self, tcp_server_socket):
        """
        Sets the _tcp_server_socket
        :param tcp_server_socket:
        :return: None
        """
        self._tcp_server_socket = tcp_server_socket

    def stop(self):
        """
        Closes tcp socket
        :return: None
        """
        try:
            logging.debug("TCP server will be stopped now")
            self.get_tcp_server_socket().close()

        except socket.herror as e:
            logging.debug("TCPServerSocket was still active and has been closed now", e)
        except IOError as e:
            logging.error("Error occurred while trying to close TCPServerSocket (IOException)", e)

        logging.debug("TCP server stopped")
