#######################################################
#
# TLSServer.py
# Python implementation of the Class TLSServer
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 12:06:57
# Original author: Fabian.Stichtenoth
#
#######################################################
from secc.transportLayer.StatefulTransportLayerServer import StatefulTransportLayerServer
from secc.transportLayer.ConnectionHandler import ConnectionHandler
from shared.enumerations.GlobalValues import GlobalValues
from shared.utils.SecurityUtils import SecurityUtils

import logging
import threading
import socket
import ssl

_unique_tls_server_instance = None


class TLSServer(StatefulTransportLayerServer):

    def __init__(self):
        super().__init__()
        self._unique_tls_server_instance = TLSServer()
        self._tls_client_socket = None
        self._tls_server_socket = None
        self._interrupt = False
        self.subscribers = set()

    # TODO: is implementation of Observer pattern correct?
    def register(self, who):
        """
        Register (addObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.add(who)

    def unregister(self, who):
        """
        Unregister (deleteObserver) method of Observer pattern
        :param who:
        :return: None
        """
        self.subscribers.discard(who)

    def dispatch(self, obj):
        """
        Dispatch method of Observer pattern. Calls update method in the subscriber class and makes reaction possible
        :return: None
        """
        for subscriber in self.subscribers:
            subscriber.update(obj)

    @classmethod
    def get_instance(cls):
        """
        Checks if an _unique_tls_server_instance already exists and initializes one if not
        :return _unique_tls_server_instance:
        """
        global _unique_tls_server_instance
        if _unique_tls_server_instance is None:
            _unique_tls_server_instance = TLSServer()
        return _unique_tls_server_instance

    def get_tls_client_socket(self):
        """
        Returns the _tls_client_socket
        :return _tls_client_socket:
        """
        return self._tls_client_socket

    def get_tls_server_socket(self):
        """
        Returns the _tls_server_socket
        :return _tls_server_socket:
        """
        return self._tls_server_socket

    def initialize(self):
        """Used to check the correct initialization of a TLS server which is a prerequisite for establishing a V2G
        communication session.
        :return: bool; True if the initialization of the TLS server was successful, False otherwise
        """
        super().initialize()

        try:
            SecurityUtils.set_ssl_context(str(GlobalValues.SECC_KEYSTORE_FILEPATH),
                                          str(GlobalValues.SECC_TRUSTSTORE_FILEPATH),
                                          str(GlobalValues.PASSPHRASE_FOR_CERTIFICATES_AND_KEYS))

            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)

            cipher = 'TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256'
            context.set_ciphers(cipher)

            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.bind((self.get_server_address(), self.get_server_port()))
            s.listen(50)

            logging.info("TLS server initialized at link-local address " +
                         self.get_tls_server_socket().gethostname() + " and port " +
                         self.get_tls_client_socket().getsockname()[1])

        except IOError as e:
            logging.fatal("IOException while trying to initialize TLS server", e)
            return False
        except TypeError:
            logging.fatal("NullPointerException while trying to set keystores, resource path to keystore/truststore "
                          "might be incorrect")
            return False

        return True

    def run(self):
        """
        Checks that session isn't interrupted, accepts incoming connection, logs address and socket and notifies
        observer
        :return: None
        """
        try:
            while not self._interrupt:
                logging.info("Waiting for new TLS client connection ...")
                self.set_tls_client_socket(self.get_tls_server_socket().accept())

                logging.info("TLS client connection with IP address " +
                             self.get_tls_client_socket().gethostname() + " and port " +
                             self.get_tls_client_socket().getsockname()[1])

                connectionHandler = ConnectionHandler(self._tls_client_socket, socket_type="tls")

                # TODO: not sure if implementation of the following line is correct
                self.dispatch(connectionHandler)

        except IOError as e:
            logging.error(e.__class__.__name__ + " occurred while running TLSServer")
        finally:
            self.stop()
        pass

    def set_tls_client_socket(self, tls_client_socket):
        """
        Sets the _tls_client_socket
        :param tls_client_socket:
        :return: None
        """
        self._tls_client_socket = tls_client_socket
        pass

    def set_tls_server_socket(self, tls_server_socket):
        """
        Sets the _tls_server_socket
        :param tls_server_socket:
        :return: None
        """
        self._tls_server_socket = tls_server_socket
        pass

    def stop(self):
        """
        Closes tls socket
        :return: None
        """
        try:
            logging.debug("TLS server will be stopped now")
            self.get_tls_server_socket().close()

        except socket.herror as e:
            logging.debug("TLSServerSocket was still active and has been closed now", e)
        except IOError as e:
            logging.error("Error occurred while trying to close TLSServerSocket (IOException)", e)

            logging.debug("TLS server stopped")
        pass
