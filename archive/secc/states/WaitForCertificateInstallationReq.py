#######################################################
# 
# WaitForCertificateInstallationReq.py
# Python implementation of the Class WaitForCertificateInstallationReq
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:57:15
# Original author: Fabian.Stichtenoth
# 
#######################################################
import logging

from shared.v2gMessages.msgDef.ResponseCodeType import ResponseCodeType
from shared.v2gMessages.msgDef.CertificateInstallationResType import CertificateInstallationResType
from shared.v2gMessages.msgDef.BodyBaseType import BodyBaseType
from shared.v2gMessages.msgDef.SignatureType import SignatureType
from shared.v2gMessages.msgDef.CertificateChainType import CertificateChainType
from shared.v2gMessages.msgDef.CertificateInstallationReqType import CertificateInstallationReqType
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from shared.v2gMessages.msgDef.MessageHeaderType import MessageHeaderType
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.utils.SecurityUtils import SecurityUtils
from shared.enumerations.PKI import PKI
from shared.enumerations.V2GMessages import V2GMessages
from shared.misc.State import State
from secc.session.V2GCommunicationSessionSECC import V2GCommunicationSessionSECC
from secc.states.ServerState import ServerState
from secc.backend.IBackendInterface import IBackendInterface


class WaitForCertificateInstallationReq(ServerState):

    def __init__(self, comm_session_context):
        super().__init__(comm_session_context)
        self._certificate_installation_res: CertificateInstallationResType = CertificateInstallationResType()

    def get_response_message(self):
        """
        Returns the _certificate_installation_res
        :return _certificate_installation_res: CertificateInstallationResType
        """
        return self._certificate_installation_res

    def __is_response_code_ok(self, certificate_installation_req, sa_contract_certificate_chain, signature):
        """
        Checks SA contract certificate chain, response code and verifies signature. If everything works, True is
        returned, else False
        :param certificate_installation_req:
        :param sa_contract_certificate_chain:
        :param signature:
        :return: bool
        """
        oem_prov_cert = SecurityUtils.get_certificate(certificate_installation_req.get_oem_provisioning_cert())

        if sa_contract_certificate_chain is None or sa_contract_certificate_chain.get_certificate() is None:
            self._certificate_installation_res.set_response_code(ResponseCodeType.FAILED_NO_CERTIFICATE_AVAILABLE)
            return False

        response_code = SecurityUtils.verify_validity_period(oem_prov_cert)
        if response_code is not ResponseCodeType.OK:
            self._certificate_installation_res.set_response_code(response_code)
            return False

        response_code = SecurityUtils.verify_leaf_certificate_attributes(oem_prov_cert, PKI.OEM)
        if response_code is not ResponseCodeType.OK:
            self._certificate_installation_res.set_response_code(ResponseCodeType.FAILED)
            return False

        verify_xml_sig_ref_elements = {certificate_installation_req.get_id(): SecurityUtils.generate_digest(
            certificate_installation_req.get_id(), self.get_message_handler().get_jaxb_element(
                certificate_installation_req))}

        if not SecurityUtils.verify_signature(signature, self.get_message_handler().get_jaxb_element(
                signature.get_signed_info()), verify_xml_sig_ref_elements,
                                              certificate_installation_req.get_oem_provisioning_cert):
            self._certificate_installation_res.set_response_code(ResponseCodeType.FAILED_SIGNATURE_ERROR)
            return False

        return True

    def process_incoming_message(self, message):
        """
        Initiates check if message is valid. If so, checks if response code is ok. If successful,
        _certificate_installation_res-parameters are set and the get_xml_signature_ref_elements is updated. If
        everything works, get_send_message is called based on the PAYMENT_DETAILS_REQ Response Code, if not it is called
        based on the FAILED_SEQUENCE_ERROR Type
        :param message:
        :return: get_send_message
        """
        if self.is_incoming_message_valid(message, CertificateInstallationReqType.__class__,
                                          self._certificate_installation_res):
            v2g_message_req = message
            certificate_installation_req = v2g_message_req.get_body().get_body_element().get_value()
            sa_contract_certificate_chain = self.get_comm_session_context().get_backend_interface().\
                get_contract_certificate_chain(
                SecurityUtils.get_certificate(certificate_installation_req.get_oem_provisioning_cert()))

            if self.__is_response_code_ok(certificate_installation_req, sa_contract_certificate_chain,
                                          v2g_message_req.get_header().get_signature()):
                ec_keypair = SecurityUtils.get_ec_keypair()
                if ec_keypair is None:
                    logging.error("EC keypair could not be generated")
                    return None

                encrypted_contract_cert_private_key = SecurityUtils.encrypt_contract_cert_private_key(
                    SecurityUtils.get_certificate(
                        certificate_installation_req.get_oem_provisioning_cert()).get_public_key(), ec_keypair,
                    self.get_comm_session_context().get_backend_interface().get_contract_certificate_private_key())

                self._certificate_installation_res.set_contract_signature_cert_chain(sa_contract_certificate_chain)
                self._certificate_installation_res.get_contract_signature_cert_chain().set_id("id1")
                self._certificate_installation_res.set_contract_signature_encrypted_private_key(
                    encrypted_contract_cert_private_key)
                self._certificate_installation_res.get_contract_signature_encrypted_private_key().set_id("id2")
                self._certificate_installation_res.set_dh_public_key(SecurityUtils.get_dh_public_key(ec_keypair))
                self._certificate_installation_res.get_dh_public_key().set_id("id3")
                self._certificate_installation_res.set_emaid(SecurityUtils.get_emaid(sa_contract_certificate_chain))
                self._certificate_installation_res.get_emaid().set_id("id4")
                self._certificate_installation_res.set_sa_provisioning_certificate_chain(
                    self.get_comm_session_context().get_backend_interface().get_cps_certificate_chain())

                self.get_xml_signature_ref_elements()[
                    self._certificate_installation_res.get_contract_signature_cert_chain().get_id()] = \
                    SecurityUtils.generate_digest(
                    self._certificate_installation_res.get_contract_signature_cert_chain().get_id(),
                    self.get_message_handler().get_jaxb_element(
                        self._certificate_installation_res.get_contract_signature_cert_chain()))
                self.get_xml_signature_ref_elements()[
                    self._certificate_installation_res.get_contract_signature_encrypted_private_key().get_id()] = \
                    SecurityUtils.generate_digest(
                    self._certificate_installation_res.get_contract_signature_encrypted_private_key().get_id(),
                    self.get_message_handler().get_jaxb_element(
                        self._certificate_installation_res.get_contract_signature_encrypted_private_key()))
                self.get_xml_signature_ref_elements()[
                    self._certificate_installation_res.get_dh_public_key().get_id()] = SecurityUtils.generate_digest(
                    self._certificate_installation_res.get_dh_public_key().get_id(),
                    self.get_message_handler().get_jaxb_element(
                        self._certificate_installation_res.get_dh_public_key()))
                self.get_xml_signature_ref_elements()[
                    self._certificate_installation_res.get_emaid().get_id()] = SecurityUtils.generate_digest(
                    self._certificate_installation_res.get_emaid().get_id(),
                    self.get_message_handler().get_jaxb_element(self._certificate_installation_res.get_emaid()))

                self.set_signature_private_key(
                    self.get_comm_session_context().get_backend_interface().get_cps_leaf_private_key())

            else:
                self.set_mandatory_fields_for_failed_res(self._certificate_installation_res,
                                                         self._certificate_installation_res.get_response_code())

        else:
            if self._certificate_installation_res.get_response_code() == ResponseCodeType.FAILED_SEQUENCE_ERROR:
                response_message = self.get_sequence_error_res_message(CertificateInstallationResType(), message)
                return self.get_send_message(response_message, V2GMessages.NONE,
                                             self._certificate_installation_res.get_response_code())

            else:
                self.set_mandatory_fields_for_failed_res(self._certificate_installation_res,
                                                         self._certificate_installation_res.get_response_code())

        return self.get_send_message(self._certificate_installation_res, V2GMessages.PAYMENT_DETAILS_REQ,
                                     self._certificate_installation_res.get_response_code())
