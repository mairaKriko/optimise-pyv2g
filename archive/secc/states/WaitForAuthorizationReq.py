#######################################################
# 
# WaitForAuthorizationReq.py
# Python implementation of the Class WaitForAuthorizationReq
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:56:42
# Original author: Fabian.Stichtenoth
# 
#######################################################
import logging
import numpy as np

from shared.v2gMessages.msgDef.EVSEProcessingType import EVSEProcessingType
from shared.v2gMessages.msgDef.MessageHeaderType import MessageHeaderType
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from shared.v2gMessages.msgDef.ResponseCodeType import ResponseCodeType
from shared.v2gMessages.msgDef.PaymentOptionType import PaymentOptionType
from shared.v2gMessages.msgDef.AuthorizationResType import AuthorizationResType
from shared.v2gMessages.msgDef.BodyBaseType import BodyBaseType
from shared.v2gMessages.msgDef.SignatureType import SignatureType
from shared.v2gMessages.msgDef.AuthorizationReqType import AuthorizationReqType
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.utils.SecurityUtils import SecurityUtils
from shared.misc.State import State
from shared.enumerations.V2GMessages import V2GMessages
from secc.session.V2GCommunicationSessionSECC import V2GCommunicationSessionSECC
from secc.states.ServerState import ServerState


class WaitForAuthorizationReq(ServerState):

    def __init__(self, comm_session_context):
        super().__init__(comm_session_context)
        self._authorization_res: AuthorizationResType = AuthorizationResType()
        self._authorization_finished: bool = False

    def get_response_message(self):
        """
        Returns the _authorization_res
        :return _authorization_res: AuthorizationResType
        """
        return self._authorization_res

    def is_authorization_finished(self):
        """
        Returns a parameter that indicates if authorization was finished
        :return _authorization_finished: bool
        """
        return self._authorization_finished

    def is_response_code_ok(self, authorization_req: AuthorizationReqType, signature):
        """
        Checks the payment method. If not external, gen challenge is checked and afterwards, if tls is chosen, the
        signature is verified. If everything works, True is returned, else False
        :param authorization_req: AuthorizationReqType
        :param signature:
        :return: bool
        """
        if self.get_comm_session_context().get_selected_payment_option() == PaymentOptionType.EXTERNAL_PAYMENT:
            if authorization_req.get_gen_challenge() is not None:
                logging.warning("EVCC sent a challenge parameter but " + PaymentOptionType.EXTERNAL_PAYMENT +
                                " has been chosen. The challenge parameter should not be present and will be ignored.")

            return True

        if not np.array_equal(authorization_req.get_gen_challenge(),
                              self.get_comm_session_context().get_gen_challenge()):
            self._authorization_res.set_response_code(ResponseCodeType.FAILED_CHALLENGE_INVALID)
            return False

        if self.get_comm_session_context().is_tls_connection() and \
                self.get_comm_session_context().get_selected_payment_option() == PaymentOptionType.CONTRACT:
            verify_xml_sig_ref_elements = {authorization_req.get_id(): SecurityUtils.generate_digest(
                authorization_req.get_id(), self.get_message_handler().get_jaxb_element(authorization_req))}

            if not SecurityUtils.verify_signature(
                    signature, self.get_message_handler().get_jaxb_element(signature.get_signed_info()),
                    verify_xml_sig_ref_elements,
                    self.get_comm_session_context().get_contract_signature_cert_chain().get_certificate()):
                self._authorization_res.set_response_code(ResponseCodeType.FAILED_SIGNATURE_ERROR)
                return False
        return True

    def process_incoming_message(self, message):
        """
        Initiates check if message is valid. If so, response code is checked and authorization is set to finished.
        get_send_message-call gets returned based on the Processing Type
        :param message:
        :return: get_send_message
        """
        if self.is_incoming_message_valid(message, AuthorizationReqType.__class__, self._authorization_res):
            v2g_message_req = message
            authorization_req = v2g_message_req.get_body().get_body_element().get_value()

            if self.is_response_code_ok(authorization_req, v2g_message_req.get_header().get_signature()):
                self.set_authorization_finished(True)

                if self.is_authorization_finished():
                    self._authorization_res.set_evse_processing(EVSEProcessingType.FINISHED)
                    return self.get_send_message(self._authorization_res, V2GMessages.CHARGE_PARAMETER_DISCOVERY_REQ)

                else:
                    self._authorization_res.set_evse_processing(EVSEProcessingType.ONGOING)
                    return self.get_send_message(self._authorization_res, V2GMessages.AUTHORIZATION_REQ)

            else:
                self.set_mandatory_fields_for_failed_res(self._authorization_res,
                                                         self._authorization_res.get_response_code())

        else:
            if self._authorization_res.get_response_code() == ResponseCodeType.FAILED_SEQUENCE_ERROR:
                response_message = self.get_sequence_error_res_message(AuthorizationReqType(), message)
                return self.get_send_message(response_message, V2GMessages.NONE,
                                             self._authorization_res.get_response_code())

            else:
                self.set_mandatory_fields_for_failed_res(self._authorization_res,
                                                         self._authorization_res.get_response_code())

        return self.get_send_message(self._authorization_res, V2GMessages.NONE,
                                     self._authorization_res.get_response_code())

    def set_authorization_finished(self, authorization_finished):
        """
        Sets the _authorization_finished parameter
        :param authorization_finished:
        :return: None
        """
        self._authorization_finished = authorization_finished
