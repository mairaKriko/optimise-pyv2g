#######################################################
# 
# WaitForCertificateUpdateReq.py
# Python implementation of the Class WaitForCertificateUpdateReq
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:57:31
# Original author: Fabian.Stichtenoth
# 
#######################################################
import logging

from shared.v2gMessages.msgDef.ResponseCodeType import ResponseCodeType
from shared.v2gMessages.msgDef.CertificateUpdateResType import CertificateUpdateResType
from shared.v2gMessages.msgDef.BodyBaseType import BodyBaseType
from shared.v2gMessages.msgDef.SignatureType import SignatureType
from shared.v2gMessages.msgDef.CertificateUpdateReqType import CertificateUpdateReqType
from shared.v2gMessages.msgDef.CertificateChainType import CertificateChainType
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.utils.SecurityUtils import SecurityUtils
from shared.enumerations.GlobalValues import GlobalValues
from shared.enumerations.PKI import PKI
from secc.session.V2GCommunicationSessionSECC import V2GCommunicationSessionSECC
from secc.states.ServerState import ServerState
from secc.backend.IBackendInterface import IBackendInterface
from shared.misc.State import State
from shared.enumerations.V2GMessages import V2GMessages


class WaitForCertificateUpdateReq(ServerState):

    def __init__(self, comm_session_context: V2GCommunicationSessionSECC):
        super().__init__(comm_session_context)
        self._certificate_update_res = CertificateUpdateResType()

    def get_response_message(self):
        """
        Returns the _certificate_update_res
        :return _certificate_update_res: CertificateUpdateResType
        """
        return self._certificate_update_res
        pass

    def __is_response_code_ok(self, certificate_update_req: CertificateUpdateReqType, signature: SignatureType) -> bool:
        """
        Checks if contract certificate is available and if so, initiates validation of certificate. Also validates
        signature and returns True if everything worked and False otherwise
        :param certificate_update_req:
        :param signature:
        :return: bool
        """
        sa_contract_certificate_chain: CertificateChainType = self.get_comm_session_context().get_backend_interface().\
            get_contract_certificate_chain(certificate_update_req.get_contract_signature_cert_chain())

        if sa_contract_certificate_chain is None or sa_contract_certificate_chain.get_certificate() is None:
            self._certificate_update_res.set_response_code(ResponseCodeType.FAILED_NO_CERTIFICATE_AVAILABLE)
            return False

        else:
            self._certificate_update_res.set_contract_signature_cert_chain(sa_contract_certificate_chain)

        cert_chain_response_code = SecurityUtils.verify_certificate_chain(
            certificate_update_req.get_contract_signature_cert_chain(),
            str(GlobalValues.SECC_TRUSTSTORE_FILEPATH), PKI.MO)

        if cert_chain_response_code is not ResponseCodeType.OK:
            self._certificate_update_res.set_response_code(cert_chain_response_code)
            return False

        verify_xml_sig_ref_elements = {certificate_update_req.get_id(): SecurityUtils.generate_digest(
            certificate_update_req.get_id(), self.get_message_handler().get_jaxb_element(certificate_update_req))}

        if not SecurityUtils.verify_signature(
                signature,
                self.get_message_handler().get_jaxb_element(signature.get_signed_info()),
                verify_xml_sig_ref_elements,
                certificate_update_req.get_contract_signature_cert_chain().get_certificate()
        ):
            self._certificate_update_res.set_response_code(ResponseCodeType.FAILED_SIGNATURE_ERROR)
            return False

        return True

    def process_incoming_message(self, message):
        """
        Initiates check if message is valid and if so also checks response code. Also checks the Diffie-Hellmann-key.
        Extracts key and sets _certificate_update_res-parameters. Adjusts get_xml_signature_ref_elements. Returns
        get_send_message based on the Response Code. If everything worked, it is called based on PAYMENT_DETAILS_REQ
        :param message:
        :return: get_send_message
        """
        if self.is_incoming_message_valid(message, CertificateUpdateReqType.__class__, self._certificate_update_res):
            v2g_message_req: V2GMessage = message
            certificate_update_req = v2g_message_req.get_body().get_body_element().get_value()

            if self.__is_response_code_ok(certificate_update_req, v2g_message_req.get_header().get_signature()):
                ecdh_key_pair = SecurityUtils.get_ec_keypair()

                if ecdh_key_pair is None:
                    logging.error("ECDH keypair could not be generated")
                    return None

                # TODO: not sure how to implement .getPublicKey()
                encrypted_contract_cert_private_key = SecurityUtils.encrypt_contract_cert_private_key(
                    SecurityUtils.get_certificate(
                        certificate_update_req.get_contract_signature_cert_chain().get_certificate()).getPublicKey(),
                    ecdh_key_pair,
                    self.get_comm_session_context().get_backend_interface().get_contract_certificate_private_key())

                self._certificate_update_res.get_contract_signature_cert_chain().set_id("id1")
                self._certificate_update_res.set_contract_signature_encrypted_private_key(
                    encrypted_contract_cert_private_key)
                self._certificate_update_res.get_contract_signature_encrypted_private_key().set_id("id2")
                self._certificate_update_res.set_dh_public_key(SecurityUtils.get_dh_public_key(ecdh_key_pair))
                self._certificate_update_res.get_dh_public_key().set_id("id3")
                self._certificate_update_res.set_emaid(SecurityUtils.get_emaid(
                    certificate_update_req.get_contract_signature_cert_chain))
                self._certificate_update_res.get_emaid().set_id("id4")
                self._certificate_update_res.set_sa_provisioning_certificate_chain(
                    self.get_comm_session_context().get_backend_interface().get_cps_certificate_chain())

                if not str(self._certificate_update_res.get_response_code()).startswith("OK"):
                    self._certificate_update_res.set_retry_counter(0)

                self.get_xml_signature_ref_elements()[
                    self._certificate_update_res.get_contract_signature_cert_chain().get_id()] = \
                    SecurityUtils.generate_digest(
                        self._certificate_update_res.get_contract_signature_cert_chain().get_id(),
                        self.get_message_handler().get_jaxb_element(
                            self._certificate_update_res.get_contract_signature_cert_chain()))
                self.get_xml_signature_ref_elements()[
                    self._certificate_update_res.get_contract_signature_encrypted_private_key().get_id()] = \
                    SecurityUtils.generate_digest(
                        self._certificate_update_res.get_contract_signature_encrypted_private_key().get_id(),
                        self.get_message_handler().get_jaxb_element(
                            self._certificate_update_res.get_contract_signature_encrypted_private_key()))
                self.get_xml_signature_ref_elements()[
                    self._certificate_update_res.get_dh_public_key().get_id()] = SecurityUtils.generate_digest(
                    self._certificate_update_res.get_dh_public_key().get_id(),
                    self.get_message_handler().get_jaxb_element(self._certificate_update_res.get_dh_public_key()))
                self.get_xml_signature_ref_elements()[
                    self._certificate_update_res.get_emaid().get_id()] = SecurityUtils.generate_digest(
                    self._certificate_update_res.get_emaid().get_id(),
                    self.get_message_handler().get_jaxb_element(self._certificate_update_res.get_emaid()))

                self.set_signature_private_key(
                    self.get_comm_session_context().get_backend_interface().get_cps_leaf_private_key())

            else:
                self.set_mandatory_fields_for_failed_res(self._certificate_update_res,
                                                         self._certificate_update_res.get_response_code())

        else:
            if self._certificate_update_res.get_response_code() == ResponseCodeType.FAILED_SEQUENCE_ERROR:
                response_message = self.get_sequence_error_res_message(CertificateUpdateResType(), message)
                return self.get_send_message(response_message, V2GMessages.NONE,
                                             self._certificate_update_res.get_response_code())

            else:
                self.set_mandatory_fields_for_failed_res(self._certificate_update_res,
                                                         self._certificate_update_res.get_response_code())

        if str(self._certificate_update_res.get_response_code()).startswith("OK"):
            next_expected_message = V2GMessages.PAYMENT_DETAILS_REQ

        else:
            next_expected_message = V2GMessages.NONE

        return self.get_send_message(self._certificate_update_res, next_expected_message,
                                     self._certificate_update_res.get_response_code())
