#######################################################
# 
# WaitForPowerDeliveryReq.py
# Python implementation of the Class WaitForPowerDeliveryReq
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:59:40
# Original author: Fabian.Stichtenoth
# 
#######################################################
import logging
import sys
from lxml import etree

from shared.v2gMessages.msgDef.PowerDeliveryResType import PowerDeliveryResType
from shared.v2gMessages.msgDef.SAScheduleTupleType import SAScheduleTupleType
from shared.v2gMessages.msgDef.BodyBaseType import BodyBaseType
from shared.v2gMessages.msgDef.ChargingProfileType import ChargingProfileType
from shared.v2gMessages.msgDef.ChargeProgressType import ChargeProgressType
from shared.v2gMessages.msgDef.PowerDeliveryReqType import PowerDeliveryReqType
from shared.v2gMessages.msgDef.ResponseCodeType import ResponseCodeType
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from shared.v2gMessages.msgDef.EVSENotificationType import EVSENotificationType
from shared.v2gMessages.msgDef.SAScheduleListType import SAScheduleListType
from shared.v2gMessages.msgDef.PMaxScheduleType import PMaxScheduleType
from shared.v2gMessages.msgDef.PMaxScheduleEntryType import PMaxScheduleEntryType
from shared.v2gMessages.msgDef.ProfileEntryType import ProfileEntryType
from shared.v2gMessages.msgDef.ACEVSEStatusType import ACEVSEStatusType
from shared.v2gMessages.msgDef.DCEVSEStatusCodeType import DCEVSEStatusCodeType
from shared.v2gMessages.msgDef.DCEVStatusType import DCEVStatusType
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.enumerations.V2GMessages import V2GMessages
from secc.session.V2GCommunicationSessionSECC import V2GCommunicationSessionSECC
from secc.states.ServerState import ServerState
from secc.evseController.IACEVSEController import IACEVSEController
from secc.evseController.IDCEVSEController import IDCEVSEController
from secc.evseController.IEVSEController import IEVSEController


class WaitForPowerDeliveryReq(ServerState):

    def __init__(self, comm_session_context: V2GCommunicationSessionSECC):
        super().__init__(comm_session_context)
        self._power_delivery_res: PowerDeliveryResType = PowerDeliveryResType()

    def __get_chosen_sa_schedule_tuple(self, chosen_sa_schedule_tuple_id):
        """
        Checks if SA schedules were chosen and if so, returns SA schedule
        :param chosen_sa_schedule_tuple_id:
        :return sa_schedule: SAScheduleTupleType
        """
        for sa_schedule in self.get_comm_session_context().get_sa_schedules().get_sa_schedule_tuple():
            if sa_schedule.get_sa_schedule_tuple_id() == chosen_sa_schedule_tuple_id:
                return sa_schedule

        return None

    def get_response_message(self) -> BodyBaseType:
        """
        Returns the _power_delivery_res
        :return _power_delivery_res: BodyBaseType
        """
        return self._power_delivery_res

    @staticmethod
    def __is_charging_profile_valid(chosen_sa_schedule_tuple: SAScheduleTupleType,
                                    charging_profile: ChargingProfileType) -> bool:
        """
        Checks if there is a charging profile and checks if all entries in charging profile are valid and within the
        correct range. Returns True if so, False otherwise
        :param chosen_sa_schedule_tuple: SAScheduleTupleType
        :param charging_profile: ChargingProfileType
        :return: bool
        """
        limit = chosen_sa_schedule_tuple.get_p_max_schedule().get_p_max_schedule_entry()

        if charging_profile is None:
            logging.error("ChargingProfile is empty (null)")
            return False

        for profile_entry in charging_profile.get_profile_entry():
            if profile_entry.get_charging_profile_entry_max_number_of_phases_in_use() is not None \
                    and profile_entry.get_charging_profile_entry_max_number_of_phases_in_use() == 2:
                logging.error(
                    "Parameter MaxNumberOfPhasesInUse of one ChargingProfile entry element is 2 which is not allowed."
                    + "Only 1 or 3 are valid values.")
                return False

            profile_entry_start = profile_entry.get_charging_profile_entry_start()
            profile_entry_power = profile_entry.get_charging_profile_entry_max_power().get_value() * pow(
                10, profile_entry.get_charging_profile_entry_max_power().get_multiplier())

            for i in range(0, len(limit), 2):
                p_max_schedule_interval_start = limit.get(i).get_time_interval().get_value().get_start()

                try:
                    p_max_schedule_interval_end = limit.get(i + 1).get_time_interval().get_value().get_start()

                except IndexError:
                    if limit.get(i).get_time_interval().get_value().get_duration() is not 0:
                        p_max_schedule_interval_end = p_max_schedule_interval_start + limit.get(
                            i).get_time_interval().get_value().get_duration()

                    else:
                        p_max_schedule_interval_end = sys.maxsize

                p_max_schedule_interval_p_max = limit.get(i).get_p_max().get_value() * pow(10, limit.get(
                    i).get_p_max().get_multiplier())

                if p_max_schedule_interval_start <= profile_entry_start < p_max_schedule_interval_end:
                    if profile_entry_power > p_max_schedule_interval_p_max:
                        logging.error("ChargingProfile entry element starting at " + profile_entry_start +
                                      "s exceeds power limit. Limit is " + p_max_schedule_interval_p_max +
                                      " W, ChargingProfile entry's max power value is " + profile_entry_power + " W")
                        return False

                    else:
                        break

                else:
                    continue

        return True

    def is_response_code_ok(self, power_delivery_req: PowerDeliveryReqType) -> bool:
        """
        Checks if EVCC wants to renegotiate and if so, logs it and sets response code to FAILED. Also checks if there is
        a chosen SA schedule and that if charge progress is start, there has also is a valid charging profile. Then
        checks if AC or DC and acts accordingly. Returns True if everything is ok, False otherwise
        :param power_delivery_req: PowerDeliveryReqType
        :return: bool
        """
        chosen_sa_schedule = self.__get_chosen_sa_schedule_tuple(power_delivery_req.get_sa_schedule_tuple_id())

        if power_delivery_req.get_charge_progress() == ChargeProgressType.RENEGOTIATE \
                and not self.get_comm_session_context().is_charge_progress_started():
            logging.error("EVCC wants to renegotiate, but charge progress has not started yet (no "
                          + "PowerDeliveryReq with ChargeProgress=START has been received before)")
            self._power_delivery_res.set_response_code(ResponseCodeType.FAILED)
            return False

        if chosen_sa_schedule is None:
            logging.warning("Chosen SAScheduleTupleID in PowerDeliveryReq is null, but parameter is mandatory")
            self._power_delivery_res.set_response_code(ResponseCodeType.FAILED_TARIFF_SELECTION_INVALID)
            return False

        if power_delivery_req.get_charge_progress() == ChargeProgressType.START \
                and not self.__is_charging_profile_valid(chosen_sa_schedule, power_delivery_req.get_charging_profile()):
            self._power_delivery_res.set_response_code(ResponseCodeType.FAILED_CHARGING_PROFILE_INVALID)
            return False

        if str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("AC"):
            if self.get_comm_session_context().get_ac_evse_controller().get_ac_evse_status(None).is_rcd():
                logging.error("RCD has detected an error")
                self._power_delivery_res.set_response_code(ResponseCodeType.FAILED_POWER_DELIVERY_NOT_APPLIED)
                return False

        else:
            dc_evse_status_code: DCEVSEStatusCodeType = self.get_comm_session_context().get_dc_evse_controller() \
                .get_dc_evse_status(None).get_evse_status_code()

            if (
                    dc_evse_status_code == DCEVSEStatusCodeType.EVSE_NOT_READY
                    or dc_evse_status_code == DCEVSEStatusCodeType.EVSE_SHUTDOWN
                    or dc_evse_status_code == DCEVSEStatusCodeType.EVSE_EMERGENCY_SHUTDOWN
                    or dc_evse_status_code == DCEVSEStatusCodeType.EVSE_MALFUNCTION
            ):
                logging.error("EVSE status code is '" + str(dc_evse_status_code) + "'")
                return False

        if (
                power_delivery_req.get_charge_progress() == ChargeProgressType.START
                and not self.get_comm_session_context().get_evse_controller().close_contactor()
        ) or (
                power_delivery_req.get_charge_progress() == ChargeProgressType.STOP
                and not self.get_comm_session_context().get_evse_controller().open_contactor()
        ):
            self._power_delivery_res.set_response_code(ResponseCodeType.FAILED_CONTACTOR_ERROR)
            return False

        return True

    def process_incoming_message(self, message) -> ReactionToIncomingMessage:
        """
        Initiates check if message is valid, then checks for response code and charge progress and acts accordingly.
        Returns call of get_send_message based on charge progess and response code
        :param message:
        :return: get_send_message (ReactionToIncomingMessage)
        """
        if self.is_incoming_message_valid(message, PowerDeliveryReqType.__class__, self._power_delivery_res):
            v2g_message_req: V2GMessage = message
            power_delivery_req: PowerDeliveryReqType = v2g_message_req.get_body().get_body_element().get_value()

            if self.is_response_code_ok(power_delivery_req):
                self.get_comm_session_context().set_chosen_sa_schedule_tuple(
                    power_delivery_req.get_sa_schedule_tuple_id())
                logging.debug("ChargeProgress of PowerDeliveryReq set to '" + str(
                    power_delivery_req.get_charge_progress())
                              + "'")
                self.set_evse_status(self._power_delivery_res)

                if power_delivery_req.get_charge_progress() == ChargeProgressType.START:
                    self.get_comm_session_context().set_charge_progress_started(True)

                    if str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("AC"):
                        return self.get_send_message(self._power_delivery_res, V2GMessages.CHARGING_STATUS_REQ)

                    else:
                        return self.get_send_message(self._power_delivery_res, V2GMessages.CURRENT_DEMAND_REQ)

                elif power_delivery_req.get_charge_progress() == ChargeProgressType.STOP:
                    if str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("AC"):
                        return self.get_send_message(self._power_delivery_res, V2GMessages.SESSION_STOP_REQ)

                    else:
                        self.get_comm_session_context().get_states().get(V2GMessages.FORK).get_allowed_requests.append(
                            V2GMessages.WELDING_DETECTION_REQ)
                        self.get_comm_session_context().get_states().get(V2GMessages.FORK).get_allowed_requests.append(
                            V2GMessages.SESSION_STOP_REQ)
                        return self.get_send_message(self._power_delivery_res, V2GMessages.FORK)

                else:
                    return self.get_send_message(self._power_delivery_res, V2GMessages.CHARGE_PARAMETER_DISCOVERY_REQ)

            else:
                self.set_mandatory_fields_for_failed_res(self._power_delivery_res,
                                                         self._power_delivery_res.get_response_code())

        else:
            if self._power_delivery_res.get_response_code() == ResponseCodeType.FAILED_SEQUENCE_ERROR:
                response_message = self.get_sequence_error_res_message(PowerDeliveryResType(), message)
                return self.get_send_message(response_message, V2GMessages.NONE,
                                             self._power_delivery_res.get_response_code())

            else:
                self.set_mandatory_fields_for_failed_res(self._power_delivery_res,
                                                         self._power_delivery_res.get_response_code())

        return self.get_send_message(self._power_delivery_res, V2GMessages.NONE,
                                     self._power_delivery_res.get_response_code())

    def set_evse_status(self, power_delivery_res: PowerDeliveryResType):
        """
        Checks for AC or DC and creates XML-representation of jaxb_evse_status and sets evse status based on it
        :param power_delivery_res:
        :return: None
        """
        if str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("AC"):

            # TODO: JAXBElement needs to be changed
            xml_cont: dict = vars(
                self.get_comm_session_context().get_ac_evse_controller().get_ac_evse_status(EVSENotificationType.NONE))

            jaxb_evse_status = etree.Element(str("urn_iso_15118_2_2013_MsgDataTypes"))

            for k, v in xml_cont.items():
                element = etree.SubElement(jaxb_evse_status, 'AC_EVSEStatus')
                element.set(str(k), v)

            power_delivery_res.set_evse_status(jaxb_evse_status)

        elif str(self.get_comm_session_context().get_requested_energy_transfermode()).startswith("DC"):

            # TODO: JAXBElement needs to be changed
            xml_cont: dict = vars(
                self.get_comm_session_context().get_dc_evse_controller().get_dc_evse_status(EVSENotificationType.NONE))

            jaxb_ac_evse_status = etree.Element(str("urn_iso_15118_2_2013_MsgDataTypes"))

            for k, v in xml_cont.items():
                element = etree.SubElement(jaxb_ac_evse_status, 'DC_EVSEStatus')
                element.set(str(k), v)

            power_delivery_res.set_evse_status(jaxb_ac_evse_status)

        else:
            logging.warning("RequestedEnergyTransferMode '"
                            + str(self.get_comm_session_context().get_requested_energy_transfermode())
                            + "is neither of type AC nor DC")
        pass
