#######################################################
# 
# WaitForPaymentDetailsReq.py
# Python implementation of the Class WaitForPaymentDetailsReq
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 11:59:00
# Original author: Fabian.Stichtenoth
# 
#######################################################
import logging
import time

from shared.v2gMessages.msgDef.PaymentDetailsResType import PaymentDetailsResType
from shared.v2gMessages.msgDef.BodyBaseType import BodyBaseType
from shared.v2gMessages.msgDef.PaymentDetailsReqType import PaymentDetailsReqType
from shared.v2gMessages.msgDef.ResponseCodeType import ResponseCodeType
from shared.v2gMessages.msgDef.V2GMessage import V2GMessage
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.utils.SecurityUtils import SecurityUtils
from shared.enumerations.GlobalValues import GlobalValues
from shared.enumerations.PKI import PKI
from shared.enumerations.V2GMessages import V2GMessages
from secc.session.V2GCommunicationSessionSECC import V2GCommunicationSessionSECC
from secc.states.ServerState import ServerState


class WaitForPaymentDetailsReq(ServerState):

    def __init__(self, comm_session_context: V2GCommunicationSessionSECC):
        super().__init__(comm_session_context)
        self._payment_details_res: PaymentDetailsResType = PaymentDetailsResType()

    def get_response_message(self) -> BodyBaseType:
        """
        Returns the _payment_details_res
        :return _payment_details_res: PaymentDetailsResType
        """
        return self._payment_details_res

    def is_response_code_ok(self, payment_details_req: PaymentDetailsReqType) -> bool:
        """
        Checks for contract signature certificate and if response code is ok. Also checks if contract is still validate
        or if it expires soon or if it is canceled. If everything is ok, True is returned
        :param payment_details_req: PaymentDetailsReqType
        :return: bool
        """
        if payment_details_req.get_contract_signature_cert_chain() is None:
            logging.error("Certificate chain is NULL")
            self._payment_details_res.set_response_code(ResponseCodeType.FAILED_CERT_CHAIN_ERROR)
            return False

        cert_chain_response_code: ResponseCodeType = SecurityUtils.verify_certificate_chain(
            payment_details_req.get_contract_signature_cert_chain(), str(GlobalValues.SECC_TRUSTSTORE_FILEPATH), PKI.MO)

        if not cert_chain_response_code == ResponseCodeType.OK:
            self._payment_details_res.set_response_code(cert_chain_response_code)
            return False

        if SecurityUtils.get_validity_period(
                SecurityUtils.get_certificate(
                    payment_details_req.get_contract_signature_cert_chain().get_certificate())) \
                <= int(GlobalValues.CERTIFICATE_EXPIRES_SOON_PERIOD):
            self._payment_details_res.set_response_code(ResponseCodeType.OK_CERTIFICATE_EXPIRES_SOON)

        if not SecurityUtils.is_emaid_syntax_valid(SecurityUtils.get_certificate(
                payment_details_req.get_contract_signature_cert_chain().get_certificate())):
            self._payment_details_res.set_response_code(ResponseCodeType.FAILED_CONTRACT_CANCELED)
            return False

        return True

    def process_incoming_message(self, message) -> ReactionToIncomingMessage:
        """
        Initiates check if message is valid and checks for response code. If so, logs timestamp and sets gen challenge.
        If not, get_send_message is called on Type NONE. If everything works, next expected message is AUTHORIZATION_REQ
        and get_send_message is called on it
        :param message:
        :return: get_send_message (ReactionToIncomingMessage)
        """
        if self.is_incoming_message_valid(message, PaymentDetailsReqType.__class__, self._payment_details_res):
            v2g_message_req: V2GMessage = message
            payment_details_req: PaymentDetailsReqType = v2g_message_req.get_body().get_body_element().get_value()

            if self.is_response_code_ok(payment_details_req):
                self.get_comm_session_context().set_contract_signature_cert_chain(
                    payment_details_req.get_contract_signature_cert_chain())

                self._payment_details_res.set_evse_timestamp(time.time())
                gen_challenge = SecurityUtils.generate_random_number(16)
                self.get_comm_session_context().set_gen_challenge(gen_challenge)
                self._payment_details_res.set_gen_challenge(gen_challenge)

            else:
                self.set_mandatory_fields_for_failed_res(self._payment_details_res,
                                                         self._payment_details_res.get_response_code())

        else:
            if self._payment_details_res.get_response_code() == ResponseCodeType.FAILED_SEQUENCE_ERROR:
                response_message: BodyBaseType = self.get_sequence_error_res_message(PaymentDetailsResType(), message)
                return self.get_send_message(response_message, V2GMessages.NONE,
                                             self._payment_details_res.get_response_code())

            else:
                self.set_mandatory_fields_for_failed_res(self._payment_details_res,
                                                         self._payment_details_res.get_response_code())

        if str(self._payment_details_res.get_response_code()).startswith("OK"):
            next_expected_message = V2GMessages.AUTHORIZATION_REQ
        else:
            next_expected_message = V2GMessages.NONE

        return self.get_send_message(self._payment_details_res, next_expected_message,
                                     self._payment_details_res.get_response_code())
