#######################################################
# 
# WaitForWeldingDetectionReq.py
# Python implementation of the Class WaitForWeldingDetectionReq
# Generated by Enterprise Architect
# Created on:      07-Jan-2021 12:01:52
# Original author: Fabian.Stichtenoth
# 
#######################################################
from shared.v2gMessages.msgDef.WeldingDetectionResType import WeldingDetectionResType
from shared.v2gMessages.msgDef.WeldingDetectionReqType import WeldingDetectionReqType
from shared.v2gMessages.msgDef.BodyBaseType import BodyBaseType
from shared.v2gMessages.msgDef.EVSENotificationType import EVSENotificationType
from shared.v2gMessages.msgDef.ResponseCodeType import ResponseCodeType
from shared.messageHandling.ReactionToIncomingMessage import ReactionToIncomingMessage
from shared.enumerations.V2GMessages import V2GMessages
from secc.session.V2GCommunicationSessionSECC import V2GCommunicationSessionSECC
from secc.states.ServerState import ServerState


class WaitForWeldingDetectionReq(ServerState):

    def __init__(self, comm_session_context: V2GCommunicationSessionSECC):
        super().__init__(comm_session_context)
        self._welding_detection_res: WeldingDetectionResType = WeldingDetectionResType()

    def get_response_message(self) -> BodyBaseType:
        """
        Returns the _welding_detection_res
        :return _welding_detection_res: BodyBaseType
        """
        return self._welding_detection_res

    def process_incoming_message(self, message) -> ReactionToIncomingMessage:
        """
        Initiates check if message is valid and if so adds states and sets _welding_detection_res-parameters. If not,
        get_send_message is called based on the response code FAILED_SEQUENCE_ERROR
        :param message:
        :return: ReactionToIncomingMessage
        """
        if self.is_incoming_message_valid(message, WeldingDetectionReqType.__class__, self._welding_detection_res):
            v2g_message_req = message
            welding_detection_req = v2g_message_req.get_body().get_body_element().get_value()

            evse_controller = self.get_comm_session_context().get_dc_evse_controller()

            self._welding_detection_res.set_dc_evse_status(
                evse_controller.get_dc_evse_status(EVSENotificationType.NONE))
            self._welding_detection_res.set_evse_present_voltage(evse_controller.get_present_voltage())

            self.get_comm_session_context().get_states().get(V2GMessages.FORK).get_allowed_requests.append(
                V2GMessages.WELDING_DETECTION_REQ)
            self.get_comm_session_context().get_states().get(V2GMessages.FORK).get_allowed_requests.append(
                V2GMessages.SESSION_STOP_REQ)

        else:
            if self._welding_detection_res.get_response_code() == ResponseCodeType.FAILED_SEQUENCE_ERROR:
                response_message = self.get_sequence_error_res_message(WeldingDetectionResType(), message)

                return self.get_send_message(response_message, V2GMessages.NONE,
                                             self._welding_detection_res.get_response_code())

            else:
                self.set_mandatory_fields_for_failed_res(self._welding_detection_res,
                                                         self._welding_detection_res.get_response_code())

        if str(self._welding_detection_res.get_response_code()).startswith("OK"):
            v2g_mes = V2GMessages.FORK

        else:
            v2g_mes = V2GMessages.NONE

        return self.get_send_message(
            self._welding_detection_res, v2g_mes, self._welding_detection_res.get_response_code())
